--- 
title: "Adpated MAPPPD Adélie Model - Student t"
author: "Christian Che-Castaldo, Emma Talis"
date: "`r Sys.Date()`"
site: bookdown::bookdown_site
documentclass: book
description: "Documention for adapted MAPPPD Adélie model - Student t Distribution"
---

# Required

## R Packages

The following R packages are required to perform this analysis.

```{r setup_false, eval = FALSE, echo = TRUE}
library(mapppdr)
library(tidyverse)
library(patchwork)
library(leaflet)
library(CCAMLRGIS)
library(rjags)
library(MCMCvis)
library(parallel)
library(stringi)
library(pander)
library(testthat)
library(stringi)
library(LaplacesDemon)
```

```{r setup, include = FALSE}

# old lab comp
#setwd("/Volumes/GoogleDrive-106535158817273811802/My Drive/Heavy Tailed Distributions/Final Adele Models Submission/acbr_m-vrajyz32bdpr_studentt_nosite_3gamma_16sigmas")
# yellow lab comp
setwd("~/GoogleDrive/Heavy Tailed Distributions/MAPPPD_adelie_models-main/acbr_m-vrajyz32bdpr_studentt_nosite_3gamma_16sigmas")
library(mapppdr)
library(tidyverse)
library(patchwork)
library(leaflet)
library(CCAMLRGIS)
library(rjags)
library(MCMCvis)
library(bayesplot)
library(parallel)
library(stringi)
library(pander)
library(testthat)
library(stringi)
library(truncnorm)
library(LaplacesDemon) ### student t r dist

# load needed objects from completed JAGS sim and actual runs
load(file = "_static/model_sim_rinits_output.rda")
load(file = "_static/model_sim.rda")
load(file = "_static/model_data_rinits_output.rda")
load(file = "_static/model_data.rda")
load(file = "_static/SiteList.rda")
load(file = "_static/w_df.rda")

options(dplyr.summarise.inform = FALSE)
```

## Model ID

```{r, echo = FALSE} 
set.seed(20)
(id <- paste0("m-", stri_rand_strings(1, 12, pattern = "[a-z0-9]"), "-studentt"))
```

## Environment

This analysis was performed using the R computing environment specified below.

````{r, echo = FALSE}
pander(sessionInfo())
```

<!--chapter:end:index.Rmd-->

# Model Description {#modeldes}

We used a Bayesian state-space model to estimate annual Adélie nest abundances for all 271 known Adélie breeding sites from 1970 -- 2020, with an extra decade to 2030 to illustrate forecasting power. We model the intrinsic rate of growth $r_{it}$, for the $i_{th}$ site in $t_{th}$ season as a function of site effects. We purposefully avoided additional covariates as to create a simplistic default model whose predictive ability could be compared to that of more biologically nuanced process models. 

## Observation errors {#obserror}

Counts were provided by the observer(s) as the nest or chick count $y$ along with an associated accuracy score (which we convert to measurement error) such that $y$ represented a draw from a distribution:

$$\big[\,y \mid lz, \sigma^{2}_{o} \,\big]\textrm{,}$$

centered on the "true", or latent, count $lz$ whose dispersion was controlled by $\sigma^{2}_{o}$, which represented the uncertainty in the count due to measurement imprecision. The accuracy scores were selected from a 5 point scale that penguin census counters traditionally use to represent count precision (Croxall and Kirkwood, 1979). Based on this scale, if 100 nests was the true count then the 95% confidence intervals for each accuracy category's distribution was defined as:

| Reported accuracy | Reported 95% confidence interval |
|-------------------|-------------------------|
| 1 | (95, 105) |
| 2 | (90, 110) |
| 3 | (75, 125) |
| 4 | (50, 150) |
| 5 | (40, 245) |

Table 1: Reported accuracy categories and their confidence intervals.

We used the log-normal distribution to model the observation process, as all counts must be positive. However, the confidence intervals (with the exception of category 5) were symmetric around the true count and did not correspond to the skewed credible intervals generated by the log-normal distribution. To compute the appropriate scale parameters for each accuracy category, we defined a function `min.RSS` that outputed the squared deviations between the upper and lower confidence interval (Table 1) and the 0.975 and 0.025 quantiles from the cumulative density function for a log-normal distribution whose median was 100. We then used the `optim` function to select the scale parameter $\sigma_{o}$ that minimized the sums of squares for each accuracy category. For example:

``` {r, eval = FALSE, echo = TRUE}
min.RSS <- function(par = 0.02, start = 95, end = 105) {
  (qlnorm(0.9775, log(100), par) - end)^2 + (qlnorm(0.0225, log(100), par) - start)^2
}
optim(par = 0.02, min.RSS, method = "Brent", lower = 1e-04, upper = 10)
```

Using the optimized scale parameters, we computed 95% confidence intervals from log-normal distributions whose median was 100, i.e. the location parameter $\mu$ = log(100). To do this, we converted each scale parameter into its geometric standard deviations $(s^{*}=e^{\sigma_{o}})$ and calculated the 95% confidence interval as $(lz(s^{*})^{-2}, lz(s^{*})^{2})$. The scale parameters used in the Adélie observation model, their geometric standard deviations, and the adjusted 95% confidence intervals for each accuracy category were:

| Reported accuracy | Reported 95% CI | Adjusted 95% CI | $\sigma_{o}$ |
|-------------------|-------------------------|------------------|----------------------------------|
| 1 | (95, 105) | (95, 105) | 0.025 | 
| 2 | (90, 110) | (91, 110) | 0.050 |
| 3 | (75, 125) | (79, 127) | 0.120 |
| 4 | (50, 150) | (64, 156) | 0.230 | 
| 5 | (40, 245) | (41, 245) | 0.510 | 

Table 2: Reported accuracy categories mapped to log-normal scale parameters used in the Adélie model.

<br>

## Abundance process models {#bioprocess}

### Nest abundance

We build our nest abundance model modeling logged abundance using the *student t* distribution. Adopting Gelman and Hill's (2007) bracket notation for assigning group membership (for example, $s[35]=2$ means that the $35^{th}$ unit in the data ($i = 35$) is from group 2), we start by modeling "true" (hereafter latent) nest abundance $z_{i,t}$ at the $i_{th}$ breeding site located on or adjacent to the Antarctic Peninsula $(s=1)$ or continent $(s=2)$ in the $t_{th}$ season as:

$$
\log(z_{i,t}) \sim \textrm{student}t \big(\mu_{i,t} = \log(z_{i,t-1}e^{r_{i}}), \sigma^2, \nu \big)\textrm{,} (\#eq:lnnests)
$$
where the mean of the student t distribution, $\mu_{i,t}$, is a deterministic model for discrete exponential growth, such that nest abundance $z_{i,t}$ is the product of nest abundance in the previous season $z_{i,t-1}$ at the site and the intrinsic rate of growth, $r_{i}$. We model the intrinsic growth rate as the sum of a grand mean $\gamma$ and site effects $\eta_{i}$:

$$
r_{i} = \gamma + \eta_{i},(\#eq:rintrinsic)
$$
where each modeled hierarchically as:

\begin{align} 
\eta_{i} & \sim \textrm{normal} \big(0, \sigma^{2}_{site}\big)(\#eq:intrinsicml)
\end{align}

In Equation \@ref(eq:lnnests) $\sigma^{2}$ represents process error, or the variation in logged (confusingly) latent nest abundance due to unmodeled biotic or abiotic processes not captured by the simple growth model embedded as the distribution's median; $\nu$ is the degrees of freedom of the student t distribution.


### Chick abundance {#chickabundance}

We modeled the latent chick abundance $zc_{i,t}$ at the $i_{th}$ breeding site in the $t_{th}$ season as:

\begin{align}
zc_{i,t} & \sim \textrm{binomial} \big(N_{i,t}, \alpha_{i,t} \big) (\#eq:lchicks1)\\
N_{i,t} & = 2 \times \textrm{round}(e^{lz_{i,t}}) (\#eq:lchicks2)\\
\alpha_{i, t} & \sim \textrm{beta} \big(a = 1.875, b =  1.125\big) \textrm{.} (\#eq:lchicks3)
\end{align}

Pygoscelid penguins typically produce one chick per nest (the maximum number of chicks per nest is two), although breeding success can fluctuate considerably between sites and seasons. We use the well-informed priors $\mu = 0.5, \sigma^{2} = 0.0625$ for $\alpha_{i,t}$, the proportion of chicks produced at the $i_{th}$ site in the $t_{th}$ season, to reflect observed variation in breeding success due to environmental and demographic stochasticity. Note that, when moment-matched, these priors result in $a$ and $b$ in Equation \@ref(eq:lchicks3).

### Initial season abundance {#initialseason}

We modeled the logged latent nest abundance at the $i_{th}$ site for the first season $(t=I_{i})$ nest abundance was recorded as:

$$
lz_{i,t=I_{i}} \sim \textrm{normal} \big(0, 1000000 \big).(\#eq:inests)
$$

### Regional groups {#rgroups}

We grouped sites into the following geographic regions prior to analysis:

1. Central-west and Northwest Antarctic Peninsula
2. Southwest Antarctic Peninsula and Palmer Land
3. Elephant Island, the South Orkney Islands, and the South Shetland Islands
4. Northeast Antarctic Peninsula
5. CCAMLR sub area 88.1 and 88.2
6. CCAMLR sub area 88.3
7. CCAMLR sub area 58.4.1
8. CCAMLR sub area 58.4.2

### Hindcasting explained

We hindcast logged latent nest abundances for the $i_{th}$ site from 1970 to the season prior to the initial season a count was recorded $(t = I_{i} - 1)$ as:

$$
lz_{i,t-1} \sim \textrm{student}t \big(lz_{i,t} - \gamma - \eta_{i}, d \big)\textrm{.}
$$

This method of hindcasting was possible because the exponential growth function can be inverted, making hindcasting nest abundances functionally no different than forecasting nest abundances into the future or in seasons of missing data within a site's time series. For sites whose first season of data was 1970, hindcasting was unnecessary.

## Observation process models {#obsprocess}

We modeled the logged observed nest counts $y_{{n}_{s}}$ and chick counts $y_{{c}_{s}}$ recorded at the $i_{th}$ breeding site in the $t_{th}$ season as:

\begin{align}
y_{{n}_{i,t}} & \sim \textrm{normal} \big(lz_{i,t} - \sigma^{2}_{{n}_{i,t}}/2, \sigma^{2}_{{n}_{i,t}}\big) (\#eq:onests)\\
y_{{c}_{i,t}} & \sim \textrm{normal} \big(lz_{i,t} - \sigma^{2}_{{n}_{i,t}}/2, \sigma^{2}_{{c}_{i,t}}\big)\textrm{,} (\#eq:ochicks)
\end{align}

where $\sigma^{2}_{n_{i, t}}$ and $\sigma^{2}_{c_{i, t}}$ are the observation errors in the recorded nest and chick count, respectively. These errors are computed from the accuracy ratings reported by the observer, the details of which are outlined in Section \@ref(obserror). Note that sites can have both nest and chick counts in the same season.

## Joint distribution {#joint}

We combine the relevant equations from Sections \@ref(bioprocess) and \@ref(obsprocess) along with the necessary prior distributions to specify the joint distribution for our model. Note that we have modified Equations \@ref(eq:lchicks1), \@ref(eq:lchicks3), \@ref(eq:onests), and \@ref(eq:ochicks) using the bracket notation described above to reflect the fact that most site-season combinations lack observed counts and latent site-level chick abundances and breeding productivites are only estimated for seasons when chick counts were recorded. We chose vague priors (on the log-scale), with the exception of $\alpha$.

\begin{align}
\big[\gamma, \boldsymbol{\alpha}, \boldsymbol{\eta}, \, & \boldsymbol{\sigma}, \sigma_{site}, \mathbf{lz}, \mathbf{zc} \mid \mathbf{y_{i}}, \mathbf{y_{n}}, \mathbf{y_{c}}, \boldsymbol{\sigma_{i}}, \boldsymbol{\sigma_{n}}, \boldsymbol{\sigma_{c}} \big]  \varpropto  \\
& \prod_{v=1}^{908} \textrm{normal} \big(y_{{n}_{v}} \mid lz_{i[v],t[v]} - \sigma^{2}_{{n}_{v}}/2, \sigma^{2}_{{n}_{v}}\big) \\
& \times \prod_{v=1}^{172} \textrm{normal} \big(y_{{c}_{v}} \mid \log(zc_{i[v],t[v]}) - \sigma^{2}_{{c}_{v}}/2, \sigma^{2}_{{c}_{v}}\big) \\
& \times \textrm{binomial} \big(zc_{i[v],t[v]} \mid N_{v} = \textrm{round}(\exp(lz_{i[v],t[v]}), \alpha_{v}\big) \, \textrm{beta} \big(\alpha_{v} \mid a = 1.875, b =  1.125\big)\\
& \times \prod_{i=1}^{271} \prod_{t=I_{i}\,+\,1}^{51} \textrm{logistic} \big(lz_{i,t} \mid lz_{i,t-1} +  \eta_{t}, d \big) \nonumber \\
& \times \prod_{t=1}^{I_{i}-1} \textrm{logistic} \big(lz_{i,t-1} \mid lz_{i,t} - \eta_{t}, d \big) \nonumber \\
& \times \textrm{logistic} \big(lz_{i, t=I_{i}} \mid 0, 1\textrm{E}6 \big)\, \textrm{normal} \big(\gamma \mid 0, 2 \big) \nonumber \\
&   \textrm{normal} \big( \eta_{i} \mid 0, \sigma^{2}_{site} \big) \nonumber \\
&\times \textrm{uniform} \big( \sigma_{s} \mid 0, 2 \big) \, \textrm{uniform} \big( \sigma_{site} \mid 0, 1 \big). \nonumber \\
\end{align}

## Additional assumptions {#addassumptions}

We made several modifications to the MAPPPD data prior to modeling:

1. We converted adults counts 1:1 to nest counts. We recognize that for any individual survey, this may not be the correct conversion factor. Adult counts may be reported when surveys are done very early in the season (prior to nesting) or when nests have not yet been established and the count of adults is too small. Alternatively, surveys may be conducted at a time when more than one adult is in attendance at some nests and the count of adults is too high. Because this conversion introduces an additional uncertainty in the conversion to nests, we decreased the accuracy of adult counts by 3 categories (with a maximum category of 5) relative to the reported uncertainty in the adult count itself. This approach is quite conservative, in that we likely overestimate the true uncertainty of those adult counts. 

2. We converted chick counts 1:1 to nest counts if the chick count was the only available count the first season data were recorded for a site. This was done to ensure that the time series for all sites originated with a nest count. The choice of conversion factor was made based on observed Pygoscelid breeding productivity discussed in Section \@ref(chickabundance). 

3. If there was more than one chick or nest count for a site in a season, we kept the maximum count and discarded the others. Nest and chick counts vary during the breeding season, as surveys can occur before or after peak breeding. While we would very much prefer to model breeding phenology each season as an additional component of the mode, the data are far to sparse for this to be possible. Instead, we use only the maximum count to best approximate peak breeding.

4. Although positive nest counts are estimated for each site from 1970-2030, the modeled time series we report on the MAPPPD website suppress site counts in seasons where Adélie penguins were not observed breeding (see #1 in Section \@ref(derivedq) for more details on how this was done). The occupancy data $(w_{i,t})$ necessary to censor time series in this fashion is a combination of MAPPPD counts flattened into presence/absence data and true presence/absence data also collected in MAPPPD. This data (like all MAPPPD data) is quite sparse, and there are many seasons where we do not know whether or not a site is used for breeding. This is problematic as there are cases where Adélie breeding sites were colonized after 1970, were extirpated prior to 2020, or were used intermittently during this time period. Also, it could be unclear when these breeding status changes happened, if they occurred during a multi-year gap between observations. Fortunately, Pygoscelid penguins in general are extremely site faithful, leading to stable breeding sites over long time scales, and the overwhelming majority of Adélie breeding sites in MAPPPD are likely to have been occupied continuously during during the 51 season interval for which we modeled nest abundance. In most cases, we assumed that the last observed breeding status persisted until a counterfactual observation was made. In a few cases, where a nesting site was known from past observations to only occasionally host breeding birds, the breeding status was assumed to be absent unless it was actually observed as being present. 

## Derived quantities {#derivedq}

We computed the following derived quantities from the parameters estimated in our model:

1. The logged latent seasonal nest abundance for the $i_{th}$ site in the $t_{th}$ year, while allowing for site extirpation and colonization events, as $lza_{i,t}=lz_{i,t}\cdot w_{i,t}$. Please see #3 in Section \@ref(addassumptions) for the details regarding $w_{i,t}$.

2. The aggregated logged latent seasonal nest abundances at the CCAMLR sub-area, regional, and continental scales, as the sum the posterior distributions of $lza_{i,t}$ for all constituent sites at each spatial scale. 

3. The predicted population growth rate multiplier $\lambda_{i,t}$ as $l_{p_{i}} = e^{r_{i}}$.

3. The actual population growth rate multiplier $\lambda_{i,t}$ as $l_{a_{i,t}} = e^{lz_{i,t+1}-lz_{i,t}}$.

4. The average population growth rate multipliers $\lambda_{i}$ for each site as the geometric mean of $l_{p_{i,t}}$ and $l_{a_{i,t}}$ for all transitions $t \to t+1$ breeding occurred in both seasons $(w_{i,t}=1 \land w_{i,t+1}=1)$ between 1970 and 2030. Please see #3 in Section \@ref(addassumptions) for the details regarding $w_{i,t}$. 

## Bibliography

1. Croxall, J. P. & Kirkwood, E. D. *The distribution of penguins on the Antarctic Peninsula and Islands of the Scotia Sea*. (British Antarctic Survey, Cambridge, United Kingdom, 1979).

2. Gelman, A. & Hill, J. *Data Analysis Using Regression and Multilevel/Hierarchical Models*. (Cambridge University Press, New York, New York, 2007).



<!--chapter:end:01-description.Rmd-->

# Data Setup

## MAPPPDR to JAGS

The following R code generates the JAGS data list object needed for fitting the model. Please see Section \@ref(modeldes) for further details, especially with regards to the various commented assumptions.

```{r, eval = TRUE, echo = TRUE, message = FALSE}
min_season <- 1970
max_season <- 2020 # 2030
species <- "ADPE"

# assign the total number of seasons as n_seasons
(n_seasons <- (max_season - min_season) + 1)

SiteList <- mapppdr::penguin_obs %>%
  # keep all sites that have at least 1 count between min and max season
  dplyr::filter(count > 0 & species_id == species & season >= min_season & season <= max_season) %>%
  # create relative season index 
  mutate(season_relative = season - min_season + 1) %>%
  # determine first season a count is observed for each site
  group_by(site_id) %>%
  summarise(initial_season = min(season_relative)) %>%
  ungroup() %>%
  # join to get other site specific covariates for visualization purposes
  left_join(mapppdr::sites, by = "site_id") %>%
  # create site index for model and visualization
  mutate(site = as.numeric(as.factor(site_id))) %>%
  # great regional groupings
  mutate(region_id = case_when(
    region == "Central-west Antarctic Peninsula" ~ 1, 
    region == "Northwest Antarctic Peninsula" ~ 1,
    region == "Southwest Antarctic Peninsula" ~ 2, 
    region == "Palmer Land" ~ 2, 
    region == "Elephant Island" ~ 3, 
    region == "South Orkney Islands" ~ 3, 
    region == "South Shetland Islands" ~ 3, 
    region == "Northeast Antarctic Peninsula" ~ 4,     
    ccamlr_id == "88.1" ~ 5, 
    ccamlr_id == "88.2" ~ 5, 
    ccamlr_id == "88.3" ~ 6,
    ccamlr_id == "58.4.1" ~ 7, 
    ccamlr_id == "58.4.2" ~ 8)) %>%   
  mutate(ccamlr = case_when(
    ccamlr_id == "48.1" ~ 1, 
    ccamlr_id == "48.2" ~ 1,
    ccamlr_id == "88.1" ~ 2, 
    ccamlr_id == "88.2" ~ 2, 
    ccamlr_id == "88.3" ~ 2,
    ccamlr_id == "58.4.1" ~ 2, 
    ccamlr_id == "58.4.2" ~ 2)) %>%     
  dplyr::select(site_id, site_name, ccamlr, ccamlr_id, region = region_id, site, initial_season, latitude, longitude)

(n_sites <- nrow(SiteList))
(n_regions <- length(unique(SiteList$region)))
(n_ccamlr <- length(unique(SiteList$ccamlr)))

# create site x season template which is used throughout analysis
w_template <- SiteList %>%
  dplyr::select(site_id, site) %>%
  # expand each site by the number of seasons
  uncount(n_seasons) %>%
  # create relative season index for each site
  mutate(season_relative = rep(1:n_seasons, n_sites)) %>%
  # create season var from relative season index
  mutate(season = season_relative + min_season - 1) %>%
  arrange(season_relative, site)

w_df <- mapppdr::penguin_obs %>%
  # keep all presence/absence data and assign observation type as 1 (observed)
  dplyr::filter(species_id == species & season >= min_season & season <= max_season) %>%
  dplyr::select(site_id, season, presence) %>%
  mutate(known_w = 1) %>%
  # determine for each site x season if breeding is observed or assumed
  group_by(site_id, season) %>%
  summarise(w = base::max(presence), known_w = base::max(known_w)) %>%
  ungroup() %>%
  # join with w_template to fill in missing site x seasons with no presence/absence data
  right_join(w_template, by = c("site_id", "season")) %>%
  # assign observation type as 0 (imputed)
  mutate(known_w = replace(known_w, is.na(known_w), 0)) %>%
  arrange(site_id, season) %>%
  # impute missing presence/absence data using the following assumptions
  # ASSSUMPTION: fill in NA between (1,1) with 1
  # ASSSUMPTION: fill in NA between (0,1) with 0
  # ASSSUMPTION: fill in NA between (1,0) with 1
  # ASSSUMPTION: fill in NA between (.,1) and (1,.) with 1
  # ASSSUMPTION: fill in NA between (.,0) and (0,.) with 0
  dplyr::group_by(site_id) %>%
  tidyr::fill(w, .direction = "downup") %>%
  dplyr::ungroup() %>%
  # create second site_id var for plotting sites alphabetically in ggplot
  mutate(site_id_rev = factor(site_id, levels = rev(sort(unique(site_id))))) %>%
  dplyr::select(site_id, site_id_rev, season, site, season_relative, w, known_w)

# convert w to matrix to be used in model
w <- w_df %>%
  dplyr::select(site, season_relative, w) %>%
  # create matrix where rows are sites and columns are seasons
  pivot_wider(names_from = season_relative, values_from = w, names_sort = TRUE) %>%
  dplyr::select(-site) %>%
  as.matrix()

abundance <- mapppdr::penguin_obs %>%
  # keep all counts between min and max season
  dplyr::filter(count > 0 & species_id == species & season >= min_season & season <= max_season) %>%
  # join to get site index and initial season
  right_join(SiteList, by = "site_id") %>%
  # create relative season index 
  mutate(season_relative = season - min_season + 1) %>%
  # ASSUMPTION: increase accuracy category of all adult counts by + 3 with a max error of 5
  rowwise() %>%
  mutate(accuracy = replace(accuracy, type == "adults", base::min((accuracy[type == "adults"] + 3), 5))) %>%
  ungroup() %>%  
  mutate(type = replace(type, type == "adults", "nests")) %>%
  # ASSUMPTION: keep maximum nest and chick count reported each season for a site
  group_by(site_id, season, season_relative, type) %>%
  arrange(desc(count), accuracy) %>%
  slice_head(n = 1) %>%
  ungroup() %>%
  # ASSUMPTION: convert accuracy to the following errors/precisions
  mutate(sigma = case_when(
    accuracy == 1 ~ 0.02490061, 
    accuracy == 2 ~ 0.04955838,
    accuracy == 3 ~ 0.1201131, 
    accuracy == 4 ~ 0.2212992, 
    accuracy == 5 ~ 0.4472728)) %>%
  mutate(precision = case_when(
    accuracy == 1 ~ 1/0.02490061^2, 
    accuracy == 2 ~ 1/0.04955838^2,
    accuracy == 3 ~ 1/0.1201131^2, 
    accuracy == 4 ~ 1/0.2212992^2, 
    accuracy == 5 ~ 1/0.4472728^2)) %>%  
  dplyr::select(site_id, site, ccamlr, region, season, season_relative, initial_season, type, 
    count, presence, accuracy, sigma, precision) %>%
  arrange(site, season_relative, type, -count, accuracy, sigma, precision)  

abundance_initial <- abundance %>%
  # keep first observed count for each site's time series
  dplyr::filter(initial_season == season_relative) %>%
  # ASSUMPTION: if no nest count is available in the initial season and a chick count is then
  # assume chick count is 1:1 nest count
  group_by(site_id, season, site, season_relative) %>%
  arrange(desc(type)) %>%
  slice_head(n = 1) %>%
  ungroup() %>%
  dplyr::select(site_id, season, site, ccamlr, region, season_relative, count, sigma, precision)

abundance_nests <- abundance %>%
  # keep all nest counts after the initial season
  dplyr::filter(initial_season != season_relative & type == "nests") %>%
  dplyr::select(site_id, season, site, ccamlr, region, season_relative, count, sigma, precision)

abundance_chicks <- rbind(
  # keep all chick counts after the initial season
  abundance %>%
    dplyr::filter(initial_season != season_relative & type == "chicks") %>%
    dplyr::select(site_id, ccamlr, region, season, site, season_relative, count, sigma, precision),
  # append chick counts from initial season that were not converted to nest counts
  # meaning there was both a chick and nest count in the initial season
  abundance %>%
    dplyr::filter(initial_season == season_relative) %>%
    group_by(site_id, season, site, season_relative) %>%
    arrange(desc(type)) %>%
    slice(2) %>%
    ungroup() %>%
    dplyr::select(site_id, site, ccamlr, region, season, season_relative, count, sigma, precision))

# moment match alpha shape and rate parameters for breeding productivity
mu <- .5
sigma <- .25
a <- (mu^2 - mu^3 - mu * sigma^3) / sigma^2
b <- (mu - 2* mu^2 + mu^3 - sigma^2 + mu * sigma^3) / sigma^2

## create triregion vector
triregion <- rep(0, length(as.vector(SiteList$region)))
triregion[as.vector(SiteList$region) == 1 | as.vector(SiteList$region) == 2 | as.vector(SiteList$region) == 3 | as.vector(SiteList$region) == 4 | as.vector(SiteList$region) == 6] <- 1 # AP
triregion[as.vector(SiteList$region) == 5] <- 2 # Ross Sea
triregion[as.vector(SiteList$region) == 7 | as.vector(SiteList$region) == 8] <- 3 # Eastern Antarctica
n_triregions <- 3

## add ACBR data to SiteList
acbr_df <- read.csv(file = 'all_MAPPPD_acbr.csv')
SiteList$ACBR_ID <- acbr_df$ACBR_ID[match(SiteList$site_id, acbr_df$site_id)]
SiteList$ACBR_Name <- acbr_df$ACBR_Name[match(SiteList$site_id, acbr_df$site_id)]
SiteList$ACBR_ID <- acbr_df$ACBR_ID[match(SiteList$site_id, acbr_df$site_id)]
SiteList$ACBR_ID[SiteList$site_id == "HUKU"] <- 2
SiteList$ACBR_Name[SiteList$site_id == "HUKU"] <- "South Orkney Islands"
SiteList$ACBR_ID[SiteList$site_id == "PCOR"] <- 5
SiteList$ACBR_Name[SiteList$site_id == "PCOR"] <- "Enderby Land"
acbr_regions <- as.vector(SiteList$ACBR_ID)
n_acbr_regions <- 16 ## really 14: 1-5, 7-10, 12-16


# add ACBR data to abundance df
abundance$ACBR_ID <- SiteList$ACBR_ID[match(abundance$site_id, SiteList$site_id)]
abundance$ACBR_Name <- SiteList$ACBR_Name[match(abundance$site_id, SiteList$site_id)]
# sum(abundance$ACBR_ID == 1) # number of abundance observations for ACBR 1

# create the data list for the JAGS model
model_data <- list(
  nests = nrow(abundance_nests),
  y_n = log(abundance_nests$count), 
  precision_n = abundance_nests$precision,
  site_n = abundance_nests$site,
  season_n = abundance_nests$season_relative,
  chicks = nrow(abundance_chicks),
  y_c = log(abundance_chicks$count), 
  precision_c = abundance_chicks$precision,
  site_c = abundance_chicks$site,
  season_c = abundance_chicks$season_relative,
  y_i = log(abundance_initial$count),
  precision_i = abundance_initial$precision,
  n_sites = n_sites,
  n_seasons = n_seasons,
  n_regions = n_regions,
  n_ccamlr = n_ccamlr,
  n_triregions = n_triregions,
  n_acbr_regions = n_acbr_regions,
  s = as.vector(SiteList$initial_season),
  region = as.vector(SiteList$region),
  triregion = triregion,
  acbr_regions = acbr_regions,
  ccamlr = as.vector(SiteList$ccamlr),
  w = w,
  a = a,
  b = b)
```

```{r, echo = FALSE, eval = TRUE}
# create frame showing for each site x season whether nest, chicks, both, or nothing was observed
abundance_viz <- abundance %>%
  dplyr::select(site_id, season, type, count) %>%
  pivot_wider(names_from = type, values_from = count) %>%
  mutate(type = case_when(
    !is.na(nests) & is.na(chicks) ~ 1,
    is.na(nests) & !is.na(chicks) ~ 2, 
    !is.na(nests) & !is.na(chicks) ~ 3)) %>%
  dplyr::select(site_id, season, type)

save(model_data, file = "_static/model_data.rda")
save(SiteList, file = "_static/SiteList.rda")
save(abundance_chicks, file = "_static/abundance_chicks.rda")
save(abundance_nests, file = "_static/abundance_nests.rda")
save(abundance_initial, file = "_static/abundance_initial.rda")
save(w_df, file = "_static/w_df.rda")
save(w_template, file = "_static/w_template.rda")
```

## Site breeding visualized

```{r, eval = TRUE, echo = FALSE, fig.align = "center", fig.height = 40, fig.width = 12, warning = FALSE, fig.cap = "Seasonal presence/absence breeding data for each site. Blue (gray) filled boxes indicate the presence (absence) of breeding where border color indicates whether breeding status was observed (black) or imputed (no border)."}
ggplot(w_df, aes(x = factor(season), y = factor(site_id_rev), fill = as.factor(w))) +
  geom_tile(aes(color = as.factor(known_w), width = .8, height = .8), size = .75)  +
  scale_colour_manual(values = c("white", "black"), na.value = NA) +
  scale_fill_manual(values = alpha(c("gray", "blue"), .5), na.value = NA) +
  labs(x = "", y = "") +
  scale_y_discrete(expand = c(0, 0)) +
  scale_x_discrete(expand = c(0, 0), breaks = seq(1970, 2015, 5), 
    labels = c("1970", "1975", "1980", "1985", "1990", "1995", "2000", "2005", "2010", "2015"))  +
  theme_grey(base_size = 8) +      
  theme(
    axis.text.x = element_text(size = 10),
    axis.text.y = element_text(size = 8),
    axis.ticks = element_line(size = .6),
    plot.background = element_blank(),
    panel.background = element_blank(),
    panel.border=element_blank(),
    legend.position = "none")  
```

<!--chapter:end:02-setup.Rmd-->

# JAGS Code

```{r}
{ 
sink("_static/jags_model.jags")
cat("

model {

acbr_region_inhabit <- c(1, 2, 3, 4, 5, 7, 8, 9, 12, 13, 14, 15, 16)
# excluding 6, 10, 11 (no sites)

for (i in 1:16) {
  # process variance prior
  sigma[i] ~ dnorm(0, pow(35, -2))T(0,1)
  tau[i] <- pow(sigma[i], -2)
  
  # nu priors
  nu[i] ~ dnorm(0, pow(35, -2))T(0.05,)
  
  # intercept prior
  gamma[i] ~ dnorm(0, pow(2.75, -2))
}

# breeding success: chick conversion priors
for (i in 1:chicks) {
  alpha[i] ~ dbeta(a, b)
}


for (i in 1:n_sites) {
  lz[i, s[i]] ~ dt(0, .001, 5)
}


# observation models
# nests
for (i in 1:nests) {
  y_n[i] ~ dnorm(mu_y_n[i], precision_n[i])
  mu_y_n[i] <- lz[site_n[i], season_n[i]]
  y_n_new[i] ~ dnorm(mu_y_n[i], precision_n[i])
  y_n_sq[i] <- pow((y_n[i] - mu_y_n[i]), 2)
  y_n_sq_new[i] <- pow((y_n_new[i] - mu_y_n[i]), 2)
}

# chicks
for (i in 1:chicks) {
  N[i] <- 2 * round(exp(lz[site_c[i], season_c[i]]))
  z_c[i] ~ dbin(alpha[i], N[i])
  lz_c[i] <- log(z_c[i])
  y_c[i] ~ dnorm(mu_y_c[i], precision_c[i])
  mu_y_c[i] <- lz_c[i]
  y_c_new[i] ~ dnorm(mu_y_c[i], precision_c[i])
  y_c_sq[i] <- pow((y_c[i] - mu_y_c[i]), 2)
  y_c_sq_new[i] <- pow((y_c_new[i] - mu_y_c[i]), 2)
}

# process model
# growth rate    
for (i in 1:n_sites) {
    zr[i] <- gamma[acbr_regions[i]]
    for (t in 1:n_seasons) {
      lza[i, t] <- lz[i, t] * w[i, t]
    }
}  

# initial year abundance
for (i in 1:n_sites) {
  y_i[i] ~ dnorm(mu_y_i[i], precision_i[i])
  mu_y_i[i] <- lz[i, s[i]]
  y_i_new[i] ~ dnorm(mu_y_i[i], precision_i[i])
  y_i_sq[i] <- pow((y_i[i] - mu_y_i[i]), 2)
  y_i_sq_new[i] <- pow((y_i_new[i] - mu_y_i[i]), 2)
  
}

# abundance: initial year + 1 through max season
for (i in 1:n_sites) {
  for (t in (s[i] + 1):n_seasons) {
    lz[i, t] ~ dt(mu_lz[i, t], tau[acbr_regions[i]], nu[acbr_regions[i]]) # fat-tailed
    mu_lz[i, t] <- lz[i, t - 1] + zr[i]
  }
}

# abundance: min season through intial year - 1
for (i in 1:n_sites) {
  for (t in 1:(s[i] - 1)) {
    lz[i, s[i] - t] ~ dt(mu_lz[i, s[i] - t], tau[acbr_regions[i]], nu[acbr_regions[i]]) # fat-tailed
    mu_lz[i, s[i] - t] <- lz[i, s[i] - t + 1] - zr[i]
  }
}
 
# posterior predictive checks
y_n_sqs <- sum(y_n_sq[])
y_n_sqs_new <- sum(y_n_sq_new[])
y_i_sqs <- sum(y_i_sq[])
y_i_sqs_new <- sum(y_i_sq_new[])
y_c_sqs <- sum(y_c_sq[])
y_c_sqs_new <- sum(y_c_sq_new[])

# derived quantities
for (i in 1:n_sites) {
  l_p[i] <- exp(zr[i])
  for (t in 2:n_seasons) {
    l_a[i, t - 1] <- exp(lz[i, t] - lz[i, t - 1])
    lw_a[i, t - 1] <- ifelse(sum(w[i, (t-1):t]) == 2, l_a[i, t - 1], 1)
    lw_p[i, t - 1] <- ifelse(sum(w[i, (t-1):t]) == 2, l_p[i], 1)
  }
}

#for (i in 1:n_sites) {
#  x[i, 1:n_seasons] <- ifelse(sum(w[i, 1:n_seasons]) > 1, w[i, 1:n_seasons], #rep(1, n_seasons))
#  gl_a[i] <- ifelse(sum(w[i, 1:n_seasons]) > 1, pow(prod(lw_a[i, ]), #(1/(sum(x[i, 1:n_seasons]) - 1))), 0)
#  gl_p[i] <- ifelse(sum(w[i, 1:n_seasons]) > 1, pow(prod(lw_p[i, ]), #(1/(sum(x[i, 1:n_seasons]) - 1))), 0)
#}

}", fill = TRUE)
sink()
}
```


<!--chapter:end:03-jags_code.Rmd-->

# Simulation

We check how well our model recovers generating parameter values by simulating a dataset from Equation \@ref(joint) and then fitting these data to this model. We choose generating parameter values that induce stable or minimal growth, as it is easy over a 51 year time series to simulate runaway growth with an exponential growth model. For this reason, we set site effects to be quite small while allowing year effects, which could be offsetting, to be larger. We ask the following questions:

1. Does the model recover the parameters, including site and year effects and breeding productivity?
2. How well does the model recover latent abundance and population growth rate multipliers?
3. Are nest abundances and growth rates biased and if so is this pattern related to sparseness in the observed data? 

## Simulate data

```{r}
set.seed(5)
sigma_sim <- .15
sigma_site_sim <- .05
gamma_sim <- 0
nu_sim <- 5 ###
eta_sim <- rnorm(n_sites, 0, sigma_site_sim)
alpha_sim <- rbeta(nrow(abundance_chicks), a, b)
site_n <- model_data$site_n
season_n <- model_data$season_n
site_c <- model_data$site_c
season_c <- model_data$season_c
s <- model_data$s
# region <- model_data$region
# ccamlr <- model_data$ccamlr
sigma_n <- abundance_nests$sigma
sigma_c <- abundance_chicks$sigma
sigma_i <- abundance_initial$sigma
y_n_sim <- y_c_sim <- y_i_sim <- z_c_sim <- N_sim <- gl_a_sim <- gl_p_sim <- NA
zr_sim <-  NA ###
lz_sim <- array(NA, dim = c(n_sites, n_seasons))
l_a_sim <- l_p_sim <- lw_a_sim <- lw_p_sim <- array(NA, dim = c(n_sites, (n_seasons - 1)))

for (i in 1:n_sites) {
  lz_sim[i, s[i]] <- LaplacesDemon::rst(1, log(1000), .75, nu = 5)
  for (t in (s[i] + 1):n_seasons) {
    zr_sim[i] <- gamma_sim + eta_sim[i]
    lz_sim[i, t] <- LaplacesDemon::rst(1, lz_sim[i, (t - 1)] + zr_sim[i], sigma_sim, nu_sim)
  }
  for (t in 1:(s[i] - 1)) {
    zr_sim[i] <- gamma_sim + eta_sim[i]
    lz_sim[i, (s[i] - t)] <- LaplacesDemon::rst(1, lz_sim[i, (s[i] - t + 1)] - zr_sim[i], sigma_sim, nu_sim)
  }
}

for (i in 1:nrow(abundance_nests)) {
  y_n_sim[i] <- rnorm(1, lz_sim[site_n[i], season_n[i]], sd = sigma_n[i])
}
for (i in 1:nrow(abundance_chicks)) {
  N_sim[i] <- as.integer(2 * round(exp(lz_sim[site_c[i], season_c[i]])))
  z_c_sim[i] <- base::max(rbinom(1, N_sim[i], prob = alpha_sim[i]), 1)
  y_c_sim[i] <- rnorm(1, log(z_c_sim[i]), sd = sigma_c[i])
}
for (i in 1:nrow(abundance_initial)) {
  y_i_sim[i] <- rnorm(1, lz_sim[i, s[i]], sd = sigma_i[i])
}

for (i in 1:n_sites) {
  for (t in 2:n_seasons) {
    l_a_sim[i, t - 1] <- exp(lz_sim[i, t] - lz_sim[i, t - 1]) 
    l_p_sim[i, t - 1] <- exp(zr_sim[i])
    if (w[i, t] == 1 & w[i, t - 1] == 1) {
      lw_a_sim[i, t - 1] <- l_a_sim[i, t - 1] 
      lw_p_sim[i, t - 1] <- l_p_sim[i, t - 1] 
    } else {
      lw_a_sim[i, t - 1] <- 1
      lw_p_sim[i, t - 1] <- 1
    }
  }
}

for (i in 1:n_sites) {
  gl_a_sim[i] <- prod(lw_a_sim[i, ])^(1/(sum(w[i, 1:n_seasons]) - 1))
  gl_p_sim[i] <- prod(lw_p_sim[i, ])^(1/(sum(w[i, 1:n_seasons]) - 1))
}

# create the data list for the JAGS model
model_sim <- list(
  nests = nrow(abundance_nests),
  y_n = y_n_sim, 
  precision_n = abundance_nests$precision,
  site_n = abundance_nests$site,
  season_n = abundance_nests$season_relative,
  chicks = nrow(abundance_chicks),
  y_c = y_c_sim, 
  precision_c = abundance_chicks$precision,
  site_c = abundance_chicks$site,
  season_c = abundance_chicks$season_relative,
  y_i = y_i_sim,
  precision_i = abundance_initial$precision,
  n_sites = n_sites,
  n_seasons = n_seasons,
  # n_regions = n_regions,
  # n_ccamlr = n_ccamlr,  
  s = as.vector(SiteList$initial_season),
  # region = as.vector(SiteList$region),
  # ccamlr = as.vector(SiteList$ccamlr), 
  w = w,
  a = a,
  b = b)

save(model_sim, file = "_static/model_sim.rda")
```

## Model fitting

```{r}
random_inits <- function(model_data) {
  seed = runif(1, 1, 100000)
  gamma <- runif(1, -.025, .025)
  # sigma_region <- runif(1, .05, .1)
  sigma_site <- runif(1, .025, .05)
  # sigma_season <- runif(1, .05, .1)
  sigma <- runif(1, .05, .1)
  chicks <- model_sim$chicks
  n_sites <- model_sim$n_sites
  n_seasons <- model_sim$n_seasons
  # n_regions <- model_sim$n_regions
  s <- model_sim$s
  # region <- model_sim$region
  # ccamlr <- model_sim$ccamlr
  y_c <- model_sim$y_c
  y_i <- model_sim$y_i
  site_c <- model_sim$site_c
  season_c <- model_sim$season_c
  a <- model_sim$a
  b <- model_sim$b
  eta <- rnorm(n_sites, 0, sigma_site)
  alpha <- rbeta(chicks, a, b)
  nu <- runif(1, 1, 50)
  zr <- NA ###
  lz <- array(NA, dim = c(n_sites, n_seasons))
  #
  for (i in 1:n_sites) {
    lz[i, s[i]] <- mean(y_i[i], na.rm = TRUE)
    for (t in (s[i] + 1):n_seasons) {
      zr[i] <- gamma + eta[i]
      lz[i, t] <- LaplacesDemon::rst(1, lz[i, (t - 1)] + zr[i], sigma, nu)
    }
    for (t in 1:(s[i] - 1)) {
      zr[i] <- gamma + eta[i]
      lz[i, (s[i] - t)] <- LaplacesDemon::rst(1, lz[i, (s[i] - t + 1)] - zr[i], sigma, nu)
     }
  }

  z_c <- N <- NA
  for (i in 1:chicks) {
    if (lz[site_c[i], season_c[i]] < 0) lz[site_c[i], season_c[i]] <- 0
    N[i] <- 2 * round(exp(lz[site_c[i], season_c[i]]))
    z_c[i] <- base::max(rbinom(1, prob = alpha[i], N[i]), 1)
  }
  
  return(list(
    sigma = sigma,
    # sigma_region = sigma_region,
    sigma_site = sigma_site,
    # sigma_season = sigma_season,
    gamma = gamma,
    # beta = beta,
    eta = eta,
    nu = nu, ###
    # epsilon = epsilon,
    alpha = alpha,
    lz = lz,
    z_c = z_c,
    .RNG.name = "base::Mersenne-Twister",
    .RNG.seed = seed))
}

save(random_inits, file = "_static/random_inits.rda")
expect_error(random_inits(model_sim), NA)
```

```{r, eval = FALSE, echo = TRUE}
n.chains <- 6
n.adapt <- 3000
n.update <- 200000
n.iter <- 100000
thin <- 100
cl <- makeCluster(n.chains)
cvars <- c("model_sim", "n.adapt", "n.update", "n.iter", "thin", "params", "random_inits")
params <- c("gamma", "sigma", "sigma_site", "alpha", "eta", "z_c", "lz", "gl_a", "l_a", "y_i_new",
            "y_n_new", "y_c_new", "y_n_sqs", "y_n_sqs_new", 
            "y_i_sqs_new", "y_i_sqs", "y_c_sqs", "y_c_sqs_new", "nu")
parallel::clusterExport(cl, cvars)
out <- clusterEvalQ(cl, {
  library(rjags)
  inits <- random_inits(model_sim)
  jm = jags.model("_static/jags_model.jags", data = model_sim, n.chains = 1, n.adapt = n.adapt, 
    inits = inits)
  update(jm, n.iter = n.update)
  zm = coda.samples(jm, variable.names = params, n.iter = n.iter, thin = thin)
  return(as.mcmc(zm))
})
stopCluster(cl)
model_sim_rinits_output = mcmc.list(out)  
save(model_sim_rinits_output, file = "_static/model_sim_rinits_output.rda")
```

```{r, fig.align = "center", fig.width = 12, fig.height = 8, fig.cap = "Trace plots for average intrinsic rate of growth and model variances (reported as standard devations)"}
MCMCsummary(model_sim_rinits_output, params = c("gamma", "sigma", "sigma_site", "nu"), 
  HPD = TRUE, hpd_prob = .95, round = 3)
color_scheme_set("viridis")
bayesplot_theme_update(text = element_text(size = 14, family = "sans"))
mcmc_trace(model_sim_rinits_output, regex_pars = c("gamma", "sigma", "nu"))
```

## Posterior predictive checks

```{r}
params <- c("y_i_sqs", "y_i_sqs_new", "y_n_sqs", "y_n_sqs_new", "y_c_sqs", "y_c_sqs_new")
MCMCsummary(model_sim_rinits_output, params = params, n.eff = FALSE, round = 3)
```

```{r, fig.align = 'center', fig.width = 12, echo = FALSE}
rep_data <- MCMCvis::MCMCchains(model_sim_rinits_output, params = 'y_i_new')
tdata_i <- bayesplot::ppc_data(model_sim$y_i, rep_data)
rep_data <- MCMCvis::MCMCchains(model_sim_rinits_output, params = 'y_n_new')
tdata_n <- bayesplot::ppc_data(model_sim$y_n, rep_data)
rep_data <- MCMCvis::MCMCchains(model_sim_rinits_output, params = 'y_c_new')
tdata_c <- bayesplot::ppc_data(model_sim$y_c, rep_data)

ppc1 <- ggplot(tdata_i, aes_(x = ~value)) +
  stat_density(aes_(group = ~rep_id, color = "simulated data"), geom = "line", position = "identity", 
    size = 0.25, alpha = 0.1, trim = FALSE, bw = 'nrd0', adjust = 1, kernel = 'gaussian', n = 1024,
    data = function(x) dplyr::filter(x, !tdata_i$is_y)) +  
  stat_density(aes_(color = "y"), data = function(x) dplyr::filter(x, tdata_i$is_y), geom = "line", 
    position = "identity", lineend = "round", size = 0.5, trim = FALSE, bw = 'nrd0', adjust = 1, 
    kernel = 'gaussian', n = 1024) +
  scale_color_manual(values = c('firebrick3', 'black')) +
  theme_classic() +
  labs(title = "Initial Abundance Density Plot", x = "logged nest abundance") +
  theme(legend.position = "bottom")  

ppc2 <- ggplot(tdata_n, aes_(x = ~value)) +
  stat_density(aes_(group = ~rep_id, color = "simulated data"), geom = "line", position = "identity", 
    size = 0.25, alpha = 0.1, trim = FALSE, bw = 'nrd0', adjust = 1, kernel = 'gaussian', n = 1024,
    data = function(x) dplyr::filter(x, !tdata_n$is_y)) +  
  stat_density(aes_(color = "y"), data = function(x) dplyr::filter(x, tdata_n$is_y), geom = "line", 
    position = "identity", lineend = "round", size = 0.5, trim = FALSE, bw = 'nrd0', adjust = 1, 
    kernel = 'gaussian', n = 1024) +
  scale_color_manual(values = c('firebrick3', 'black')) +
  theme_classic() +
  labs(title = "Nest Abundance Density Plot", x = "logged nest abundance") +
  theme(legend.position = "bottom")  

ppc3 <- ggplot(tdata_c, aes_(x = ~value)) +
  stat_density(aes_(group = ~rep_id, color = "simulated data"), geom = "line", position = "identity", 
    size = 0.25, alpha = 0.1, trim = FALSE, bw = 'nrd0', adjust = 1, kernel = 'gaussian', n = 1024,
    data = function(x) dplyr::filter(x, !tdata_c$is_y)) +  
  stat_density(aes_(color = "y"), data = function(x) dplyr::filter(x, tdata_c$is_y), geom = "line", 
    position = "identity", lineend = "round", size = 0.5, trim = FALSE, bw = 'nrd0', adjust = 1, 
    kernel = 'gaussian', n = 1024) +
  scale_color_manual(values = c('firebrick3', 'black')) +
  theme_classic() +
  labs(title = "Chick Abundance Density Plot", x = "logged chick abundance") +
  theme(legend.position = "bottom")  

ppc1 + ppc2 + ppc3
```

## Posterior predictive loss

```{r}
y_i_new_mean <- MCMCsummary(model_sim_rinits_output, params = c("y_i_new"), n.eff = FALSE)[, 1]
y_i_new_sd <- MCMCsummary(model_sim_rinits_output, params = c("y_i_new"), n.eff = FALSE)[, 2]
dsel_i <- sum((model_sim$y_i - y_i_new_mean)^2) + sum(y_i_new_sd^2)
y_n_new_mean <- MCMCsummary(model_sim_rinits_output, params = c("y_n_new"), n.eff = FALSE)[, 1]
y_n_new_sd <- MCMCsummary(model_sim_rinits_output, params = c("y_n_new"), n.eff = FALSE)[, 2]
(dsel_n <- sum((model_sim$y_n - y_n_new_mean)^2) + sum(y_n_new_sd^2) + dsel_i)
y_c_new_mean <- MCMCsummary(model_sim_rinits_output, params = c("y_c_new"), n.eff = FALSE)[, 1]
y_c_new_sd <- MCMCsummary(model_sim_rinits_output, params = c("y_c_new"), n.eff = FALSE)[, 2]
(dsel_c <- sum((model_sim$y_c- y_c_new_mean)^2) + sum(y_c_new_sd^2))
save(dsel_i, dsel_n, dsel_c, file = "_static/ppl_sim.rda")
```

```{r, echo = FALSE, fig.align = "center", fig.height = 40, fig.width = 12, warning = FALSE, fig.cap = "Scaled nest posterior predictive loss by site and season."}
abundance_nests$dsel_n_sim <- (model_sim$y_n - y_n_new_mean)^2 + y_n_new_sd^2
abundance_initial$dsel_n_sim <- (model_sim$y_i - y_i_new_mean)^2 + y_i_new_sd^2
work1 <- rbind(
  abundance_nests %>% 
    dplyr::select(site, season_relative, dsel_n_sim),
  abundance_initial %>% 
    dplyr::select(site, season_relative, dsel_n_sim)) %>%
  mutate(dsel_n_sim_scaled = dsel_n_sim / base::max(dsel_n_sim)) %>%
  right_join(w_template, by = c("site", "season_relative")) %>%
  mutate(site_id_rev = factor(site_id, levels = rev(sort(unique(site_id))))) %>%
  dplyr::select(site_id, site_id_rev, season, dsel_n_sim_scaled) %>%
  arrange(site_id, season)
  
p1 <- ggplot(work1, aes(x = factor(season), y = factor(site_id_rev), fill = dsel_n_sim_scaled)) +
  geom_tile(color = "black", width = .8, height = .8, size = .3) +
  scale_fill_gradient(low = "yellow", high = "red", na.value = "white", name = "Scaled PPL") +
  labs(x = "", y = "") +
  scale_y_discrete(expand = c(0, 0)) +
  scale_x_discrete(expand = c(0, 0), breaks = seq(1970, 2015, 5), 
    labels = c("1970", "1975", "1980", "1985", "1990", "1995", "2000", "2005", "2010", "2015"))  +
  theme_grey(base_size = 8) +      
  theme(
    axis.text.x = element_text(size = 10),
    axis.text.y = element_text(size = 8),
    axis.ticks = element_line(size = .6),
    plot.background = element_blank(),
    panel.background = element_blank(),
    panel.border=element_blank(),
    legend.position = "bottom",
    legend.key.width = unit(2, "cm"))
p1
```

```{r, echo = FALSE, fig.align = "center", fig.height = 40, fig.width = 12, warning = FALSE, fig.cap = "Scaled chick posterior predictive loss by site and season."}
abundance_chicks$dsel_c_sim <- (model_sim$y_c - y_c_new_mean)^2 + y_c_new_sd^2
work2 <- abundance_chicks %>%
  dplyr::select(site, season_relative, dsel_c_sim) %>%
  mutate(dsel_c_sim_scaled = dsel_c_sim / base::max(dsel_c_sim)) %>%
  right_join(w_template, by = c("site", "season_relative")) %>%
  mutate(site_id_rev = factor(site_id, levels = rev(sort(unique(site_id))))) %>%
  dplyr::select(site_id, site_id_rev, season, dsel_c_sim_scaled) %>%
  arrange(site_id, season)
  
p2 <- ggplot(work2, aes(x = factor(season), y = factor(site_id_rev), fill = dsel_c_sim_scaled)) +
  geom_tile(color = "black", width = .8, height = .8, size = .3) +
  scale_fill_gradient(low = "yellow", high = "red", na.value = "white", name = "Scaled PPL") +
  labs(x = "", y = "") +
  scale_y_discrete(expand = c(0, 0)) +
  scale_x_discrete(expand = c(0, 0), breaks = seq(1970, 2015, 5), 
    labels = c("1970", "1975", "1980", "1985", "1990", "1995", "2000", "2005", "2010", "2015"))  +
  theme_grey(base_size = 8) +      
  theme(
    axis.text.x = element_text(size = 10),
    axis.text.y = element_text(size = 8),
    axis.ticks = element_line(size = .6),
    plot.background = element_blank(),
    panel.background = element_blank(),
    panel.border=element_blank(),
    legend.position = "bottom",
    legend.key.width = unit(2, "cm"))
p2
```

## Parameter recovery

```{r, echo = FALSE}
r_threshold <- 1.05
z_c_q <- MCMCsummary(model_sim_rinits_output, params = c("z_c"), HPD = TRUE, hpd_prob = .95, round = 3)[,c(3, 4, 5, 6)]
z_c <- cbind(data.frame(z_c_q), abundance_chicks, z_c_sim) %>%
  mutate(no_recovered = ifelse(z_c_sim >= X95._HPDL & z_c_sim <= X95._HPDU, 0, 1)) %>%
  mutate(no_converged = ifelse(Rhat <= r_threshold | is.na(Rhat), 0, 1)) %>%
  dplyr::select(site_id, site_id, season, no_recovered, no_converged) %>%
  summarise(no_recovered = sum(no_recovered), no_converged = sum(no_converged))

alpha_q <- MCMCsummary(model_sim_rinits_output, params = c("alpha"), HPD = TRUE, hpd_prob = .95, round = 3)[,c(3, 4, 5, 6)]
alpha <- cbind(data.frame(alpha_q), abundance_chicks, alpha_sim) %>%
  mutate(no_recovered = ifelse(alpha_sim >= X95._HPDL & alpha_sim <= X95._HPDU, 0, 1)) %>%
  mutate(no_converged = ifelse(Rhat <= r_threshold | is.na(Rhat), 0, 1)) %>%
  dplyr::select(site_id, site_id, season, no_recovered, no_converged) %>%
  summarise(no_recovered = sum(no_recovered), no_converged = sum(no_converged))
```

The model performs well with simulation, recovering almost all parameters. Of the `r dim(z_c_q)[1]` latent chick abundances and breeding productivity parameters, `r z_c$no_converged` abundance and `r alpha$no_converged` breeding productivity parameters failed to converge and we did not recover `r z_c$no_recovered` chick abundance and `r alpha$no_recovered` breeding productivity generating values. We visualize additional parameters more fully below. The model sometimes consistently overestimates or underestimates latent abundances ina few time series. Despite this failure, the model does better at recovering seasonal and average site population growth rate multipliers.

```{r, fig.align = "center", fig.height = 40, fig.width = 12, echo = FALSE, warning = FALSE, fig.cap = "Recovery and convergence of latent nest abundance estimates across all sites and seasons. Green (yellow) filled boxes indicate abundance the generating value was above (below) the 95% highest posterior density credible (HPDC) interval, while gray boxes indicate the generating value was within the HPDC interval. Border color indicates the type of count observed for that site and season with purple being nest only, orange being chick only, and red being both nest and chick. Black dots mark abundance estimates that failed to converge."}

lz_sim_df <- data.frame(lz_sim) %>% 
  pivot_longer(cols = starts_with('X'), names_to = 'X', values_to = 'lz_sim')
lz_q <- data.frame(MCMCsummary(model_sim_rinits_output, params = c("lz"), HPD = TRUE, hpd_prob = .95, 
  round = 3, n.eff = FALSE))[, c(3, 4, 5)]
work3 <- cbind(lz_q, w_template) %>%
  mutate(season = season_relative + min_season - 1) %>%
  arrange(site, season_relative) %>%
  mutate(lz_sim = lz_sim_df$lz_sim) %>%
  mutate(recover = case_when(
    lz_sim < X95._HPDL ~ 1, 
    lz_sim > X95._HPDU ~ 2,
    lz_sim >= X95._HPDL & lz_sim <= X95._HPDU ~ 3)) %>%
  mutate(converged = ifelse(Rhat <= r_threshold, NA, 4)) %>%
  left_join(abundance_viz, by = c("site_id", "season")) %>%
  mutate(site_id_rev = factor(site_id, levels = rev(sort(unique(site_id))))) %>%
  dplyr::select(site_id, site_id_rev, season, recover, converged, type)

p3 <- ggplot(work3, aes(x = factor(season), y = factor(site_id_rev), fill = as.factor(recover))) +
  geom_tile(aes(color = as.factor(type), width = .8, height = .8), size = .75)  +
  scale_fill_manual(values = alpha(c("yellow", "green", "gray"), .3), na.value = NA) +
  scale_colour_manual(values = c("purple", "orange", "red", "black"), na.value = NA) +
  geom_point(aes(color = as.factor(converged)), size = 1) +
  labs(x = "", y = "") +
  scale_y_discrete(expand = c(0, 0)) +
  scale_x_discrete(expand = c(0, 0), breaks = seq(1970, 2025, 5), 
    labels = c("1970", "1975", "1980", "1985", "1990", "1995", "2000", "2005", "2010", "2015", "2020", "2025"))  +
  theme_grey(base_size = 8) +      
  theme(
    axis.text.x = element_text(size = 10),
    axis.text.y = element_text(size = 8),
    axis.ticks = element_line(size = .6),
    plot.background = element_blank(),
    panel.background = element_blank(),
    panel.border=element_blank(),
    legend.position = "none")
p3
```

<br>

```{r, fig.align = "center", fig.height = 40, fig.width = 12, echo = FALSE, eval = TRUE, warning = FALSE, fig.cap = "Recovery and convergence of latent population growth rate multipliers across all sites and seasons. Green (yellow) filled boxes indicate abundance the generating value was above (below) the 95% highest posterior density credible (HPDC) interval, while gray boxes indicate the generating value was within the HPDC interval. Border color indicates the type of count observed for that site and season with purple being nest only, orange being chick only, and red being both nest and chick. Black dots mark population growth rate multipliers that failed to converge."}

l_a_sim_df <- data.frame(l_a_sim) %>% 
  pivot_longer(cols = starts_with('X'), names_to = 'X', values_to = 'l_a_sim')
l_a_q <- data.frame(MCMCsummary(model_sim_rinits_output, params = c("l_a"), HPD = TRUE, hpd_prob = .95, 
  round = 3, n.eff = FALSE))[, c(3, 4, 5)]
work4 <- cbind(l_a_q, w_template %>% 
  dplyr::filter(season_relative < n_seasons)) %>%
  mutate(season = season_relative + min_season - 1) %>%
  arrange(site, season_relative) %>%
  mutate(l_a_sim = l_a_sim_df$l_a_sim) %>%
  mutate(recover = case_when(
    l_a_sim < X95._HPDL ~ 1, 
    l_a_sim > X95._HPDU ~ 2,
    l_a_sim >= X95._HPDL & l_a_sim <= X95._HPDU ~ 3)) %>%
  mutate(converged = ifelse(Rhat <= r_threshold, NA, 4)) %>%
  left_join(abundance_viz, by = c("site_id", "season")) %>%
  mutate(site_id_rev = factor(site_id, levels = rev(sort(unique(site_id))))) %>%
  dplyr::select(site_id, site_id_rev, season, recover, converged, type)

p4 <- ggplot(work4, aes(x = factor(season), y = factor(site_id_rev), fill = as.factor(recover))) +
  geom_tile(aes(color = as.factor(type), width = .8, height = .8), size = .75)  +
  scale_fill_manual(values = alpha(c("yellow", "green", "gray"), .3), na.value = NA) +
  scale_colour_manual(values = c("purple", "orange", "red", "black"), na.value = NA) +
  geom_point(aes(color = as.factor(converged)), size = 1) +
  labs(x = "", y = "") +
  scale_y_discrete(expand = c(0, 0)) +
  scale_x_discrete(expand = c(0, 0), breaks = seq(1970, 2025, 5), 
    labels = c("1970", "1975", "1980", "1985", "1990", "1995", "2000", "2005", "2010", "2015", "2020", "2025"))  +
  theme_grey(base_size = 8) +      
  theme(
    axis.text.x = element_text(size = 10),
    axis.text.y = element_text(size = 8),
    axis.ticks = element_line(size = .6),
    plot.background = element_blank(),
    panel.background = element_blank(),
    panel.border=element_blank(),
    legend.position = "none")
p4
```

```{r, fig.align = "center", echo = FALSE, fig.cap = "Equal tailed credible intervals of the posterior distributions for average intrinsic rate of growth and model variances (reported as standard devations). Thin (thick) lines represent 95% (50%) credible intervals and points represent posterior medians. Red dots indicate generating values from the simulation."}
MCMCplot(model_sim_rinits_output, params = c("gamma", "sigma", "nu"), ISB = FALSE, horiz = TRUE, guide_lines = TRUE)
points(c(gamma_sim, sigma_sim, sigma_site_sim, nu_sim), seq(4, 1), col = "red", pch = 16)
```

```{r, fig.align = "center", fig.height = 40, echo = FALSE, fig.cap = "Equal tailed credible intervals of the posterior distributions for site effects (deviations from the average intrinsic rate of growth). Thin (thick) lines represent 95% (50%) credible intervals and points represent posterior medians. Red dots indicate generating values from the simulation."}
MCMCplot(model_sim_rinits_output, params = "eta", horiz = TRUE, labels = SiteList$site_id, sz_labels = .6, 
  guide_lines = TRUE, xlim = c(-.2, .2))
points(eta_sim, n_sites:1, col = "red", pch = 16)
```

```{r, fig.align = "center", fig.height = 40, echo = FALSE, fig.cap = "Equal tailed credible intervals of the posterior distributions for site-level average population growth rate multipliers. Thin (thick) lines represent 95% (50%) credible intervals and points represent posterior medians. Red dots indicate generating values from the simulation."}
MCMCplot(model_sim_rinits_output, params = "gl_a", horiz = TRUE, labels = SiteList$site_id, sz_labels = .6, 
  guide_lines = TRUE, ref = 1)
points(gl_a_sim, n_sites:1, col = "red", pch = 16)
```

<!--chapter:end:04-simulation.Rmd-->

# Model Fit

## Model fitting

```{r}
random_inits <- function(model_data) {
  seed = runif(1, 1, 100000)
  gamma <- runif(16, -.025, .025) # for each region
  # gamma[6] <- NA
  # gamma[10] <- NA
  # gamma[11] <- NA
  nu <- runif(16, 0.05, 40) ###   # ACBR #############
  # nu[6] <- NA
  # nu[10] <- NA
  # nu[11] <- NA
  #nu <- rtruncnorm(3, 0, 40, mean = 0, sd = 45)
  # sigma_region <- runif(1, .05, .1)
  # sigma_site <- runif(1, .025, .05)
  # sigma_season <- runif(1, .05, .1)
  sigma <- runif(16, .05, .1) ####################
  chicks <- model_data$chicks
  n_sites <- model_data$n_sites
  n_seasons <- model_data$n_seasons
  n_regions <- model_data$n_regions
  n_triregions <- model_data$n_triregions
  n_acbr_regions <- model_data$n_acbr_regions
  s <- model_data$s
  region <- model_data$region
  triregion <- model_data$triregion
  acbr_regions <- model_data$acbr_regions
  ccamlr <- model_data$ccamlr
  y_c <- model_data$y_c
  y_i <- model_data$y_i
  site_c <- model_data$site_c
  season_c <- model_data$season_c
  a <- model_data$a
  b <- model_data$b
  # eta <- rnorm(n_sites, 0, sigma_site)
  alpha <- rbeta(chicks, a, b)
  zr <- NA
  lz <- array(NA, dim = c(n_sites, n_seasons))
  #
  for (i in 1:n_sites) {
    lz[i, s[i]] <- mean(y_i[i], na.rm = TRUE)
    for (t in (s[i] + 1):n_seasons) {
      zr[i] <- gamma[acbr_regions[i]] # + eta[i]
      lz[i, t] <- LaplacesDemon::rst(1, lz[i, (t - 1)] + zr[i], sigma[acbr_regions[i]], nu[acbr_regions[i]])
    }
    for (t in 1:(s[i] - 1)) {
      zr[i] <- gamma[acbr_regions[i]] # + eta[i]
      lz[i, (s[i] - t)] <- LaplacesDemon::rst(1, lz[i, (s[i] - t + 1)] - zr[i], sigma[acbr_regions[i]], nu[acbr_regions[i]])
     }
  }

  z_c <- N <- NA
  for (i in 1:chicks) {
    if (lz[site_c[i], season_c[i]] < 0) lz[site_c[i], season_c[i]] <- 0
    N[i] <- 2 * round(exp(lz[site_c[i], season_c[i]]))
    z_c[i] <- base::max(rbinom(1, prob = alpha[i], N[i]), 1)
  }
  
  return(list(
    sigma = sigma, #######
    # sigma_site = sigma_site,
    gamma = gamma,
    # eta = eta,
    alpha = alpha,
    nu = nu, ###
    lz = lz,
    z_c = z_c,
    .RNG.name = "base::Mersenne-Twister",
    .RNG.seed = seed))
}

save(random_inits, file = "_static/random_inits.rda")
expect_error(random_inits(model_data), NA)
```

```{r, eval = FALSE, echo = TRUE}
n.chains <- 3
n.adapt <- 10000
n.update <- 25000
n.iter <- 25000
thin <- 10
cl <- makeCluster(n.chains)
cvars <- c("model_data", "n.adapt", "n.update", "n.iter", "thin", "params", "random_inits")
params <- c("gamma",  "sigma", "alpha", "z_c", "lz", "gl_a", "l_a", "y_i_new",
            "y_n_new", "y_c_new", "y_n_sqs", "y_n_sqs_new", "y_i_sqs_new", "y_i_sqs",
            "y_c_sqs", "y_c_sqs_new", "lz_c", "lza", "nu", "mu_lz")
parallel::clusterExport(cl, cvars)
out <- clusterEvalQ(cl, {
  library(rjags)
  inits <- random_inits(model_data)
  jm = jags.model("_static/jags_model.jags", data = model_data, n.chains = 1, n.adapt = n.adapt, 
    inits = inits)
  update(jm, n.iter = n.update)
  zm = coda.samples(jm, variable.names = params, n.iter = n.iter, thin = thin)
  return(as.mcmc(zm))
})
stopCluster(cl)
model_data_rinits_output = mcmc.list(out)  
save(model_data_rinits_output, file = "_static/model_data_rinits_output.rda")
```

```{r, fig.align = "center", fig.width = 12, fig.height = 8, fig.cap = "Trace plots for average intrinsic rate of growth and model variances (reported as standard devations)"}
MCMCsummary(model_data_rinits_output, params = c("gamma", "sigma", "nu"), HPD = TRUE, hpd_prob = .95, round = 3)
color_scheme_set("viridis")
bayesplot_theme_update(text = element_text(size = 14, family = "sans"))
mcmc_trace(model_data_rinits_output, regex_pars = c("sigma", "nu"))
```

```{r, fig.align='center', echo = FALSE}
sigmas <- MCMCsummary(model_data_rinits_output, params = c("sigma"), HPD = TRUE, hpd_prob = .95, round = 3)[,1]
nus <- MCMCsummary(model_data_rinits_output, params = c("nu"), HPD = TRUE, hpd_prob = .95, round = 3)[,1]
df16 <- data.frame("Region" = 1:16, "sigma" = sigmas, "nu" = nus)
library(ggplot2)
ggplot(df16, aes(x=sigma, y=nu)) +
  geom_point(
    color = "blue",
    fill = "#69b3a2",
    shape = 21,
    alpha = 0.6,
    size = 3,
    stroke = 1
    )
```


```{r, fig.align = "center", echo = FALSE}
prior <- rtruncnorm(15000, a=0.5, b=Inf, mean = 0, sd = 45)
MCMCtrace(model_data_rinits_output, params = c("nu[1]", "nu[2]", "nu[5]", "nu[6]", "nu[9]", "nu[10]", "nu[3]", "nu[4]", "nu[7]", "nu[8]", "nu[11]", "nu[12]", "nu[13]", "nu[14]", "nu[15]", "nu[16]"), priors = prior, pdf = FALSE, ISB = FALSE, exact = TRUE, type = "density")

```



```{r, fig.align = "center", echo = FALSE}
prior <- rtruncnorm(15000, a=0.5, b=Inf, mean = 0, sd = 45)
MCMCtrace(model_data_rinits_output, params = c("nu[6]", "nu[10]", "nu[11]", "nu[15]", "nu[4]", "nu[1]", "nu[12]", "nu[14]", "nu[9]", "nu[13]", "nu[2]", "nu[16]", "nu[5]", "nu[8]", "nu[7]", "nu[3]"), priors = prior, pdf = FALSE, ISB = FALSE, exact = TRUE, type = "density")

```



```{r, fig.align = "center", echo = FALSE}
prior <- rtruncnorm(15000, a=0.5, b=Inf, mean = 0, sd = 45)
MCMCtrace(model_data_rinits_output, params = c("sigma[1]", "sigma[2]", "sigma[5]", "sigma[6]", "sigma[9]", "sigma[10]", "sigma[3]", "sigma[4]", "sigma[7]", "sigma[8]", "sigma[11]", "sigma[12]", "sigma[13]", "sigma[14]", "sigma[15]", "sigma[16]"), priors = prior, pdf = FALSE, ISB = FALSE, exact = TRUE, type = "density")

```



```{r, fig.align = "center", echo = FALSE}
prior <- rtruncnorm(15000, a=0.5, b=Inf, mean = 0, sd = 45)
MCMCtrace(model_data_rinits_output, params = c("sigma[6]", "sigma[10]", "sigma[11]", "sigma[15]", "sigma[4]", "sigma[1]", "sigma[12]", "sigma[14]", "sigma[9]", "sigma[13]", "sigma[2]", "sigma[16]", "sigma[5]", "sigma[8]", "sigma[7]", "sigma[3]"), priors = prior, pdf = FALSE, ISB = FALSE, exact = TRUE, type = "density")

```

## Posterior predictive checks

```{r}
params <- c("y_i_sqs", "y_i_sqs_new", "y_n_sqs", "y_n_sqs_new", "y_c_sqs", "y_c_sqs_new")
MCMCsummary(model_data_rinits_output, params = params, n.eff = FALSE, round = 3)
```

```{r, fig.align = 'center', fig.width = 12, echo = FALSE}
rep_data <- MCMCvis::MCMCchains(model_data_rinits_output, params = 'y_i_new')
tdata_i <- bayesplot::ppc_data(model_data$y_i, rep_data)
rep_data <- MCMCvis::MCMCchains(model_data_rinits_output, params = 'y_n_new')
tdata_n <- bayesplot::ppc_data(model_data$y_n, rep_data)
rep_data <- MCMCvis::MCMCchains(model_data_rinits_output, params = 'y_c_new')
tdata_c <- bayesplot::ppc_data(model_data$y_c, rep_data)

ppc1 <- ggplot(tdata_i, aes_(x = ~value)) +
  stat_density(aes_(group = ~rep_id, color = "simulated data"), geom = "line", position = "identity", 
    size = 0.25, alpha = 0.1, trim = FALSE, bw = 'nrd0', adjust = 1, kernel = 'gaussian', n = 1024,
    data = function(x) dplyr::filter(x, !tdata_i$is_y)) +  
  stat_density(aes_(color = "y"), data = function(x) dplyr::filter(x, tdata_i$is_y), geom = "line", 
    position = "identity", lineend = "round", size = 0.5, trim = FALSE, bw = 'nrd0', adjust = 1, 
    kernel = 'gaussian', n = 1024) +
  scale_color_manual(values = c('firebrick3', 'black')) +
  theme_classic() +
  labs(title = "Initial Abundance Density Plot", x = "logged nest abundance") +
  theme(legend.position = "bottom")  

ppc2 <- ggplot(tdata_n, aes_(x = ~value)) +
  stat_density(aes_(group = ~rep_id, color = "simulated data"), geom = "line", position = "identity", 
    size = 0.25, alpha = 0.1, trim = FALSE, bw = 'nrd0', adjust = 1, kernel = 'gaussian', n = 1024,
    data = function(x) dplyr::filter(x, !tdata_n$is_y)) +  
  stat_density(aes_(color = "y"), data = function(x) dplyr::filter(x, tdata_n$is_y), geom = "line", 
    position = "identity", lineend = "round", size = 0.5, trim = FALSE, bw = 'nrd0', adjust = 1, 
    kernel = 'gaussian', n = 1024) +
  scale_color_manual(values = c('firebrick3', 'black')) +
  theme_classic() +
  labs(title = "Nest Abundance Density Plot", x = "logged nest abundance") +
  theme(legend.position = "bottom")  

ppc3 <- ggplot(tdata_c, aes_(x = ~value)) +
  stat_density(aes_(group = ~rep_id, color = "simulated data"), geom = "line", position = "identity", 
    size = 0.25, alpha = 0.1, trim = FALSE, bw = 'nrd0', adjust = 1, kernel = 'gaussian', n = 1024,
    data = function(x) dplyr::filter(x, !tdata_c$is_y)) +  
  stat_density(aes_(color = "y"), data = function(x) dplyr::filter(x, tdata_c$is_y), geom = "line", 
    position = "identity", lineend = "round", size = 0.5, trim = FALSE, bw = 'nrd0', adjust = 1, 
    kernel = 'gaussian', n = 1024) +
  scale_color_manual(values = c('firebrick3', 'black')) +
  theme_classic() +
  labs(title = "Chick Abundance Density Plot", x = "logged chick abundance") +
  theme(legend.position = "bottom")  

ppc1 + ppc2 + ppc3
```

## Posterior predictive loss

```{r}
y_i_new_mean <- MCMCsummary(model_data_rinits_output, params = c("y_i_new"), n.eff = FALSE)[, 1]
y_i_new_sd <- MCMCsummary(model_data_rinits_output, params = c("y_i_new"), n.eff = FALSE)[, 2]
dsel_i <- sum((model_data$y_i - y_i_new_mean)^2) + sum(y_i_new_sd^2)
y_n_new_mean <- MCMCsummary(model_data_rinits_output, params = c("y_n_new"), n.eff = FALSE)[, 1]
y_n_new_sd <- MCMCsummary(model_data_rinits_output, params = c("y_n_new"), n.eff = FALSE)[, 2]
(dsel_n <- sum((model_data$y_n - y_n_new_mean)^2) + sum(y_n_new_sd^2) + dsel_i)
y_c_new_mean <- MCMCsummary(model_data_rinits_output, params = c("y_c_new"), n.eff = FALSE)[, 1]
y_c_new_sd <- MCMCsummary(model_data_rinits_output, params = c("y_c_new"), n.eff = FALSE)[, 2]
(dsel_c <- sum((model_data$y_c- y_c_new_mean)^2) + sum(y_c_new_sd^2))
save(dsel_i, dsel_n, dsel_c, file = "_static/ppl.rda")
```

```{r, echo = FALSE, fig.align = "center", fig.height = 40, fig.width = 12, warning = FALSE, fig.cap = "Scaled nest posterior predictive loss by site and season."}
abundance_nests$dsel_n_sim <- (model_data$y_n - y_n_new_mean)^2 + y_n_new_sd^2
abundance_initial$dsel_n_sim <- (model_data$y_i - y_i_new_mean)^2 + y_i_new_sd^2
work1 <- rbind(
  abundance_nests %>% 
    dplyr::select(site, season_relative, dsel_n_sim),
  abundance_initial %>% 
    dplyr::select(site, season_relative, dsel_n_sim)) %>%
  mutate(dsel_n_sim_scaled = dsel_n_sim / base::max(dsel_n_sim)) %>%
  right_join(w_template, by = c("site", "season_relative")) %>%
  mutate(site_id_rev = factor(site_id, levels = rev(sort(unique(site_id))))) %>%
  dplyr::select(site_id, site_id_rev, season, dsel_n_sim_scaled) %>%
  arrange(site_id, season)
  
p1 <- ggplot(work1, aes(x = factor(season), y = factor(site_id_rev), fill = dsel_n_sim_scaled)) +
  geom_tile(color = "black", width = .8, height = .8, size = .3) +
  scale_fill_gradient(low = "yellow", high = "red", na.value = "white", name = "Scaled PPL") +
  labs(x = "", y = "") +
  scale_y_discrete(expand = c(0, 0)) +
  scale_x_discrete(expand = c(0, 0), breaks = seq(1970, 2015, 5), 
    labels = c("1970", "1975", "1980", "1985", "1990", "1995", "2000", "2005", "2010", "2015"))  +
  theme_grey(base_size = 8) +      
  theme(
    axis.text.x = element_text(size = 10),
    axis.text.y = element_text(size = 8),
    axis.ticks = element_line(size = .6),
    plot.background = element_blank(),
    panel.background = element_blank(),
    panel.border=element_blank(),
    legend.position = "bottom",
    legend.key.width = unit(2, "cm"))
p1
```

```{r, echo = FALSE, fig.align = "center", fig.height = 40, fig.width = 12, warning = FALSE, fig.cap = "Scaled chick posterior predictive loss by site and season."}
abundance_chicks$dsel_c_sim <- (model_data$y_c - y_c_new_mean)^2 + y_c_new_sd^2
work2 <- abundance_chicks %>%
  dplyr::select(site, season_relative, dsel_c_sim) %>%
  mutate(dsel_c_sim_scaled = dsel_c_sim / base::max(dsel_c_sim)) %>%
  right_join(w_template, by = c("site", "season_relative")) %>%
  mutate(site_id_rev = factor(site_id, levels = rev(sort(unique(site_id))))) %>%
  dplyr::select(site_id, site_id_rev, season, dsel_c_sim_scaled) %>%
  arrange(site_id, season)
  
p2 <- ggplot(work2, aes(x = factor(season), y = factor(site_id_rev), fill = dsel_c_sim_scaled)) +
  geom_tile(color = "black", width = .8, height = .8, size = .3) +
  scale_fill_gradient(low = "yellow", high = "red", na.value = "white", name = "Scaled PPL") +
  labs(x = "", y = "") +
  scale_y_discrete(expand = c(0, 0)) +
  scale_x_discrete(expand = c(0, 0), breaks = seq(1970, 2015, 5), 
    labels = c("1970", "1975", "1980", "1985", "1990", "1995", "2000", "2005", "2010", "2015"))  +
  theme_grey(base_size = 8) +      
  theme(
    axis.text.x = element_text(size = 10),
    axis.text.y = element_text(size = 8),
    axis.ticks = element_line(size = .6),
    plot.background = element_blank(),
    panel.background = element_blank(),
    panel.border=element_blank(),
    legend.position = "bottom",
    legend.key.width = unit(2, "cm"))
p2
```


```{r, echo = FALSE, fig.align="center", fig.cap="Histogram of nest posterior predictive loss values for site/year combinations with counts"}
df_dsel <- data.frame(abundance_nests$dsel_n_sim)

ggplot(df_dsel, aes(x=abundance_nests.dsel_n_sim)) +
  geom_histogram(binwidth=0.05, color="black", fill="#EBB261") +
  labs(title="Nest PPL histogram", x="nest posterior predictive loss")
```


## Parameter visualization

```{r, echo = FALSE}
r_threshold <- 1.05
z_c_q <- MCMCsummary(model_data_rinits_output, params = c("z_c"), HPD = TRUE, hpd_prob = .95, round = 3)[,c(3, 4, 5, 6)]
z_c <- cbind(data.frame(z_c_q), abundance_chicks) %>%
  mutate(no_converged = ifelse(Rhat <= r_threshold | is.na(Rhat), 0, 1)) %>%
  dplyr::select(site_id, site_id, season, no_converged) %>%
  summarise(no_converged = sum(no_converged))

alpha_q <- MCMCsummary(model_data_rinits_output, params = c("alpha"), HPD = TRUE, hpd_prob = .95, round = 3)[,c(3, 4, 5, 6)]
alpha <- cbind(data.frame(alpha_q), abundance_chicks) %>%
  mutate(no_converged = ifelse(Rhat <= r_threshold | is.na(Rhat), 0, 1)) %>%
  dplyr::select(site_id, site_id, season, no_converged) %>%
  summarise(no_converged = sum(no_converged))
```

Of the `r dim(z_c_q)[1]` latent chick abundances and breeding productivity parameters, `r z_c$no_converged` abundance and `r alpha$no_converged` breeding productivity parameters failed to converge. We visualize additional parameters below. 

```{r, fig.align = "center", fig.height = 40, fig.width = 12, echo = FALSE, warning = FALSE, fig.cap = "Convergence and uncertainty of latent nest abundance estimates across all sites and seasons. Border color indicates the type of count observed for that site and season with purple being nest only, orange being chick only, and red being both nest and chick. Black dots mark abundance estimates that failed to converge."}

lz_q <- data.frame(MCMCsummary(model_data_rinits_output, params = c("lz"), HPD = FALSE, hpd_prob = .95, 
  round = 3, n.eff = TRUE))[, c(1, 2, 6, 7)]
work3 <- cbind(lz_q, w_template) %>%
  mutate(season = season_relative + min_season - 1) %>%
  arrange(site, season_relative) %>%
  mutate(converged = ifelse(Rhat <= r_threshold, NA, 4)) %>%
  mutate(neff_adequate = ifelse(n.eff > 500, NA, 4)) %>%
  left_join(abundance_viz, by = c("site_id", "season")) %>%
  mutate(sd_w = sd * mean) %>%
  mutate(site_id_rev = factor(site_id, levels = rev(sort(unique(site_id))))) %>%
  dplyr::select(site_id, site_id_rev, season, sd_w, Rhat, converged, n.eff, neff_adequate, type)

p3 <- ggplot(work3, aes(x = factor(season), y = factor(site_id_rev), fill = sd_w)) +
  geom_tile(aes(color = as.factor(type), width = .8, height = .8), size = .75)  +
  scale_fill_gradient2(low = "white", high = "green", name = "Mean-weighted logged abundance SD") +
  scale_colour_manual(values = c("purple", "orange", "red", "black"), na.value = NA, guide = FALSE) +
  geom_point(aes(color = as.factor(converged)), size = 1) +
  labs(x = "", y = "") +
  scale_y_discrete(expand = c(0, 0)) +
  scale_x_discrete(expand = c(0, 0), breaks = seq(1970, 2015, 5), 
    labels = c("1970", "1975", "1980", "1985", "1990", "1995", "2000", "2005", "2010", "2015")) +
  theme_grey(base_size = 8) +      
  theme(
    axis.text.x = element_text(size = 10),
    axis.text.y = element_text(size = 8),
    axis.ticks = element_line(size = .6),
    plot.background = element_blank(),
    panel.background = element_blank(),
    panel.border = element_blank(), 
    legend.position = "bottom",
    legend.key.width = unit(2, "cm"))
p3
```

<br>

```{r, fig.align = "center", fig.height = 40, fig.width = 12, echo = FALSE, warning = FALSE, fig.cap = "Effective sample size of latent nest abundance estimates across all sites and seasons. Border color indicates the type of count observed for that site and season with purple being nest only, orange being chick only, and red being both nest and chick. Black dots mark abundance estimates that have fewer than 500 effective samples."}

p4 <- ggplot(work3, aes(x = factor(season), y = factor(site_id_rev), fill = n.eff)) +
  geom_tile(aes(color = as.factor(type), width = .8, height = .8), size = .75)  +
  scale_fill_gradient2(low = "white", high = "green", name = "Effective sample size") +
  scale_colour_manual(values = c("purple", "orange", "red", "black"), na.value = NA, guide = FALSE) +
  geom_point(aes(color = as.factor(neff_adequate)), size = 1) +
  labs(x = "", y = "") +
  scale_y_discrete(expand = c(0, 0)) +
  scale_x_discrete(expand = c(0, 0), breaks = seq(1970, 2015, 5), 
    labels = c("1970", "1975", "1980", "1985", "1990", "1995", "2000", "2005", "2010", "2015")) +
  theme_grey(base_size = 8) +      
  theme(
    axis.text.x = element_text(size = 10),
    axis.text.y = element_text(size = 8),
    axis.ticks = element_line(size = .6),
    plot.background = element_blank(),
    panel.background = element_blank(),
    panel.border = element_blank(), 
    legend.position = "bottom",
    legend.key.width = unit(2, "cm"))
p4
```

<br>

<!-- ```{r, fig.align = "center", fig.height = 40, fig.width = 12, echo = FALSE, eval = TRUE, warning = FALSE, fig.cap = " Convergence and uncertainty of latent population growth rate multipliers across all sites and seasons. Green (yellow) filled boxes indicate that the population growth multiplier 95% highest posterior density credible was above (below) 1, while gray boxes indicate the generating value was within the HPDC interval. Border color indicates the type of count observed for that site and season with purple being nest only, orange being chick only, and red being both nest and chick. Black dots mark population growth rate multipliers that failed to converge."} -->

<!-- l_a_q <- data.frame(MCMCsummary(model_data_rinits_output, params = c("l_a"), HPD = FALSE, hpd_prob = .95,  -->
<!--   round = 3, n.eff = TRUE))[, c(2, 6, 7)] -->
<!-- work4 <- cbind(l_a_q, w_template %>%  -->
<!--   dplyr::filter(season_relative < n_seasons)) %>% -->
<!--   mutate(season = season_relative + min_season - 1) %>% -->
<!--   arrange(site, season_relative) %>% -->
<!--   mutate(converged = ifelse(Rhat <= r_threshold, NA, 4)) %>% -->
<!--   mutate(neff_adequate = ifelse(n.eff > 500, NA, 4)) %>% -->
<!--   left_join(abundance_viz, by = c("site_id", "season")) %>% -->
<!--   mutate(site_id_rev = factor(site_id, levels = rev(sort(unique(site_id))))) %>% -->
<!--   dplyr::select(site_id, site_id_rev, season, sd, Rhat, converged, n.eff, neff_adequate, type) -->

<!-- p5 <- ggplot(work4, aes(x = factor(season), y = factor(site_id_rev), fill = sd)) + -->
<!--   geom_tile(aes(color = as.factor(type), width = .8, height = .8), size = .75)  + -->
<!--   scale_fill_gradient2(low = "white", high = "green", name = "Lambda SD") + -->
<!--   scale_colour_manual(values = c("purple", "orange", "red", "black"), na.value = NA, guide = FALSE) + -->
<!--   geom_point(aes(color = as.factor(converged)), size = 1) + -->
<!--   labs(x = "", y = "") + -->
<!--   scale_y_discrete(expand = c(0, 0)) + -->
<!--   scale_x_discrete(expand = c(0, 0), breaks = seq(1970, 2015, 5),  -->
<!--     labels = c("1970", "1975", "1980", "1985", "1990", "1995", "2000", "2005", "2010", "2015")) + -->
<!--   theme_grey(base_size = 8) +       -->
<!--   theme( -->
<!--     axis.text.x = element_text(size = 10), -->
<!--     axis.text.y = element_text(size = 8), -->
<!--     axis.ticks = element_line(size = .6), -->
<!--     plot.background = element_blank(), -->
<!--     panel.background = element_blank(), -->
<!--     panel.border = element_blank(),  -->
<!--     legend.position = "bottom", -->
<!--     legend.key.width = unit(2.5, "cm")) -->
<!-- p5 -->
<!-- ``` -->

```{r, fig.align = "center", echo = FALSE, fig.cap = "Equal tailed credible intervals of the posterior distributions for model variances (reported as standard devations). Thin (thick) lines represent 95% (50%) credible intervals and points represent posterior medians."}
MCMCplot(model_data_rinits_output, params = "sigma", horiz = TRUE, guide_lines = TRUE)
```


```{r, fig.align = "center", echo = FALSE, fig.cap = "Equal tailed credible intervals of the posterior distributions for degrees of freedom of student t distributions for each region (reported as standard devations). Thin (thick) lines represent 95% (50%) credible intervals and points represent posterior medians."}
MCMCplot(model_data_rinits_output, params = c("sigma[1]", "sigma[2]", "sigma[3]", "sigma[4]", "sigma[5]", "sigma[6]", "sigma[7]", "sigma[8]"), horiz = TRUE, guide_lines = TRUE, ISB = FALSE, exact = TRUE)

MCMCplot(model_data_rinits_output, params = c("sigma[9]", "sigma[10]", "sigma[11]", "sigma[12]", "sigma[13]", "sigma[14]", "sigma[15]", "sigma[16]"), horiz = TRUE, guide_lines = TRUE, ISB = FALSE, exact = TRUE)

```


```{r, fig.align = "center", echo = FALSE, fig.cap = "Equal tailed credible intervals of the posterior distributions for degrees of freedom of student t distributions for each region (reported as standard devations). Thin (thick) lines represent 95% (50%) credible intervals and points represent posterior medians."}
MCMCplot(model_data_rinits_output, params = c("nu[1]", "nu[2]", "nu[3]", "nu[4]", "nu[5]", "nu[6]", "nu[7]", "nu[8]"), horiz = TRUE, guide_lines = TRUE, ISB = FALSE, exact = TRUE)

MCMCplot(model_data_rinits_output, params = c("nu[9]", "nu[10]", "nu[11]", "nu[12]", "nu[13]", "nu[14]", "nu[15]", "nu[16]"), horiz = TRUE, guide_lines = TRUE, ISB = FALSE, exact = TRUE)

```

```{r, fig.align = "center", echo = FALSE, fig.cap = "Equal tailed credible intervals of the posterior distributions for degrees of freedom of student t distributions for each region (reported as standard devations). Thin (thick) lines represent 95% (50%) credible intervals and points represent posterior medians."}
#### by number of sites
MCMCplot(model_data_rinits_output, params = c("nu[6]", "nu[10]", "nu[11]", "nu[15]", "nu[4]", "nu[1]", "nu[12]", "nu[14]"), horiz = TRUE, guide_lines = TRUE, ISB = FALSE, exact = TRUE)

MCMCplot(model_data_rinits_output, params = c("nu[9]", "nu[13]", "nu[2]", "nu[16]", "nu[5]", "nu[8]", "nu[7]", "nu[3]"), horiz = TRUE, guide_lines = TRUE, ISB = FALSE, exact = TRUE)

```



```{r, fig.align = "center", fig.height = 40, echo = FALSE, fig.cap = "Equal tailed credible intervals of the posterior distributions for breeding productivity. Thin (thick) lines represent 95% (50%) credible intervals and points represent posterior medians."}
MCMCplot(model_data_rinits_output, params = "alpha", horiz = TRUE, sz_labels = .6, ref = .5, guide_lines = TRUE, 
  xlim = c(0, 1), labels = paste(abundance_chicks$site_id, abundance_chicks$season, sep = "-"))
```


<!-- ```{r, fig.align = "center", fig.height = 40, echo = FALSE, fig.cap = "Equal tailed credible intervals of the posterior distributions for site-level average population growth rate multipliers. Thin (thick) lines represent 95% (50%) credible intervals and points represent posterior medians."} -->
<!-- MCMCplot(model_data_rinits_output, params = "gl_a", horiz = TRUE, labels = SiteList$site_id, sz_labels = .6,  -->
<!--   guide_lines = TRUE, ref = 1, xlim = c(.6, 1.4)) -->
<!-- ``` -->

<!--chapter:end:05-model_fit.Rmd-->

# Abundance time-series


## Antarctica

```{r, echo = FALSE}
start_season <- 1980
end_season <- 2030 # 2020

gl_a_matrix <- MCMCchains(model_data_rinits_output, params = "gl_a")
gl_a_mean_sd <- MCMCsummary(model_data_rinits_output, params = "gl_a", n.eff = FALSE)[,c(1, 2)] 
gl_a_quantiles <- t(apply(gl_a_matrix, 2, function(x) quantile(x, probs = c(0.1, 0.5, 0.9))))
SiteList_lambda <- cbind(SiteList, gl_a_mean_sd, data.frame(gl_a_quantiles)) %>%
  dplyr::mutate(label_id = paste0("<b><center>", site_id, "</b>", "<br/>", 
    site_name, "<br/>", round(mean, 2), "</center>")) %>% 
  dplyr::select(site_id, site_name, ccamlr_id, site, initial_season, latitude, longitude, 
    mean, sd, gl_min = X10., gl_med = X50., gl_max = X90., label_id)

za_matrix <- exp(MCMCpstr(model_data_rinits_output, params = "lza", type = "chains")[[1]])
za_quantiles <- t(apply(apply(za_matrix, c(2, 3), sum), 1, quantile, probs = c(.1, .25, .5, .75, .9)))
za_df <- data.frame(za_quantiles) %>%
  mutate(season_relative = 1:n(), season = min_season + season_relative - 1) %>%
  dplyr::filter(season >= start_season & season <= end_season)

za_48_1_matrix <- za_matrix[SiteList_lambda$site[which(SiteList_lambda$ccamlr_id == "48.1")],,]
za_48_1_quantiles <- t(apply(apply(za_48_1_matrix, c(2, 3), sum), 1, quantile, probs = c(.1, .25, .5, .75, .9)))
za_48_1_df <- data.frame(za_48_1_quantiles) %>%
  mutate(season_relative = 1:n(), season = min_season + season_relative - 1) %>%
  dplyr::filter(season >= start_season & season <= end_season)

za_48_2_matrix <- za_matrix[SiteList_lambda$site[which(SiteList_lambda$ccamlr_id == "48.2")],,]
za_48_2_quantiles <- t(apply(apply(za_48_2_matrix, c(2, 3), sum), 1, quantile, probs = c(.1, .25, .5, .75, .9)))
za_48_2_df <- data.frame(za_48_2_quantiles) %>%
  mutate(season_relative = 1:n(), season = min_season + season_relative - 1) %>%
  dplyr::filter(season >= start_season & season <= end_season)

za_88_1_matrix <- za_matrix[SiteList_lambda$site[which(SiteList_lambda$ccamlr_id == "88.1")],,]
za_88_1_quantiles <- t(apply(apply(za_88_1_matrix, c(2, 3), sum), 1, quantile, probs = c(.1, .25, .5, .75, .9)))
za_88_1_df <- data.frame(za_88_1_quantiles) %>%
  mutate(season_relative = 1:n(), season = min_season + season_relative - 1) %>%
  dplyr::filter(season >= start_season & season <= end_season)

za_88_2_matrix <- za_matrix[SiteList_lambda$site[which(SiteList_lambda$ccamlr_id == "88.2")],,]
za_88_2_quantiles <- t(apply(apply(za_88_2_matrix, c(2, 3), sum), 1, quantile, probs = c(.1, .25, .5, .75, .9)))
za_88_2_df <- data.frame(za_88_2_quantiles) %>%
  mutate(season_relative = 1:n(), season = min_season + season_relative - 1) %>%
  dplyr::filter(season >= start_season & season <= end_season)

za_88_3_matrix <- za_matrix[SiteList_lambda$site[which(SiteList_lambda$ccamlr_id == "88.3")],,]
za_88_3_quantiles <- t(apply(apply(za_88_3_matrix, c(2, 3), sum), 1, quantile, probs = c(.1, .25, .5, .75, .9)))
za_88_3_df <- data.frame(za_88_3_quantiles) %>%
  mutate(season_relative = 1:n(), season = min_season + season_relative - 1) %>%
  dplyr::filter(season >= start_season & season <= end_season)

za_58_4_1_matrix <- za_matrix[SiteList_lambda$site[which(SiteList_lambda$ccamlr_id == "58.4.1")],,]
za_58_4_1_quantiles <- t(apply(apply(za_58_4_1_matrix, c(2, 3), sum), 1, quantile, probs = c(.1, .25, .5, .75, .9)))
za_58_4_1_df <- data.frame(za_58_4_1_quantiles) %>%
  mutate(season_relative = 1:n(), season = min_season + season_relative - 1) %>%
  dplyr::filter(season >= start_season & season <= end_season)

za_58_4_2_matrix <- za_matrix[SiteList_lambda$site[which(SiteList_lambda$ccamlr_id == "58.4.2")],,]
za_58_4_2_quantiles <- t(apply(apply(za_58_4_2_matrix, c(2, 3), sum), 1, quantile, probs = c(.1, .25, .5, .75, .9)))
za_58_4_2_df <- data.frame(za_58_4_2_quantiles) %>%
  mutate(season_relative = 1:n(), season = min_season + season_relative - 1) %>%
  dplyr::filter(season >= start_season & season <= end_season)

za_reg_list <- list()

for (i in 1:5) {
  za_reg_matrix <- za_matrix[SiteList_lambda$site[which(SiteList$region == i)],,]
  za_reg_quantiles <- t(apply(apply(za_reg_matrix, c(2, 3), sum), 1, quantile, probs = c(.1, .25, .5, .75, .9)))
  za_reg_list[[i]] <- data.frame(za_reg_quantiles) %>%
    mutate(season_relative = 1:n(), season = min_season + season_relative - 1) %>%
    dplyr::filter(season >= start_season & season <= end_season)
}

lza_matrix <- MCMCchains(model_data_rinits_output, params = "lza")
lza_quantiles <- t(apply(lza_matrix, 2, quantile, probs = c(.1, .25, .5, .75, .9)))
lza_df <- cbind(data.frame(lza_quantiles, w_template)) %>%
  dplyr::filter(season >= start_season & season <= end_season)

lz_c_matrix <- MCMCchains(model_data_rinits_output, params = "lz_c")
lz_c_quantiles <- t(apply(lz_c_matrix, 2, function(x) quantile(x, probs = c(0.1, 0.5, 0.9))))

abundance_chicks <- cbind(abundance_chicks, data.frame(lz_c_quantiles)) %>%
  rename(q_min = X10., q_med = X50., q_max = X90.)

asd_mask <- sf::st_as_sf(CCAMLRGIS::load_ASDs()) %>%
  dplyr::select(ccamlr_id = GAR_Name) %>%
  sf::st_transform(4326)
mpa_mask <- sf::st_as_sf(CCAMLRGIS::load_MPAs()) %>%
  dplyr::select(mpa_id = GAR_Name) %>%
  sf::st_transform(4326)
land_mask <- sf::st_as_sf(CCAMLRGIS::load_Coastline()) %>%
  dplyr::select(layer) %>%
  dplyr::filter(layer == "coastline") %>%
  sf::st_transform(4326)

```

```{r, echo = FALSE, fig.align = TRUE, fig.width = 12, echo = FALSE, message = FALSE, fig.cap = "Summed latent Adélie nest abundances by season for all 109 Adélie breeding sites in Antarctica from 1980-2020. Abundance posterior distributions are represented with boxplots showing the median, 25-75%, and 10-90% (whiskers) credible intervals."}

ggplot(data = za_df, aes(x = season, group = season)) +
  geom_boxplot(aes(ymin = X10., lower = X25., middle = X50., upper = X75., ymax = X90.), stat = "identity",
  width = 0.5, outlier.shape = NA, alpha = 0.8, fill = "#EBB261") +
  labs(y = "nest abudance\n", x = NULL) +
  guides(fill = FALSE, color = FALSE) +
  theme_minimal() +
  theme(text = element_text(size = 15))  
```  

```{r, echo = FALSE, fig.align = TRUE, fig.width = 8, echo = FALSE, message = FALSE, fig.cap = "Interquartile range of above boxplots vs. season"}

ggplot(IQR_df, aes(x = season, y = IQR)) +
    geom_point(color = "#9D5A6C") +
    labs(y = "interquartile range\n", x = NULL)
```  


## CCAMLR sub area

```{r, echo = FALSE, fig.align = TRUE, fig.width = 12, echo = FALSE, message = FALSE, fig.cap = "Summed latent Adélie nest abundances by season for all Adélie breeding sites in CCAMLR sub area 48.1 from 1980-2020. Abundance posterior distributions are represented with boxplots showing the median, 25-75%, and 10-90% (whiskers) credible intervals."}

ggplot(data = za_48_1_df, aes(x = season, group = season)) +
  geom_boxplot(aes(ymin = X10., lower = X25., middle = X50., upper = X75., ymax = X90.), stat = "identity",
  width = 0.5, outlier.shape = NA, alpha = 0.8, fill = "#EBB261") +
  labs(y = "nest abudance\n", x = NULL, title = "48.1") +
  guides(fill = FALSE, color = FALSE) +
  theme_minimal() +
  theme(text = element_text(size = 15))  
```  

```{r, echo = FALSE, fig.align = TRUE, fig.width = 12, echo = FALSE, message = FALSE, fig.cap = "Summed latent Adélie nest abundances by season for all Adélie breeding sites in CCAMLR sub area 48.2 from 1980-2020. Abundance posterior distributions are represented with boxplots showing the median, 25-75%, and 10-90% (whiskers) credible intervals."}

ggplot(data = za_48_2_df, aes(x = season, group = season)) +
  geom_boxplot(aes(ymin = X10., lower = X25., middle = X50., upper = X75., ymax = X90.), stat = "identity",
  width = 0.5, outlier.shape = NA, alpha = 0.8, fill = "#EBB261") +
  labs(y = "nest abudance\n", x = NULL, title = "48.2") +
  guides(fill = FALSE, color = FALSE) +
  theme_minimal() +
  theme(text = element_text(size = 15))   
```  

```{r, echo = FALSE, fig.align = TRUE, fig.width = 12, echo = FALSE, message = FALSE, fig.cap = "Summed latent Adélie nest abundances by season for all Adélie breeding sites in CCAMLR sub area 88.1 from 1980-2020. Abundance posterior distributions are represented with boxplots showing the median, 25-75%, and 10-90% (whiskers) credible intervals."}

ggplot(data = za_88_1_df, aes(x = season, group = season)) +
  geom_boxplot(aes(ymin = X10., lower = X25., middle = X50., upper = X75., ymax = X90.), stat = "identity",
  width = 0.5, outlier.shape = NA, alpha = 0.8, fill = "#EBB261") +
  labs(y = "nest abudance\n", x = NULL, title = "88.1") +
  guides(fill = FALSE, color = FALSE) +
  theme_minimal() +
  theme(text = element_text(size = 15))   
```  

```{r, echo = FALSE, fig.align = TRUE, fig.width = 12, echo = FALSE, message = FALSE, fig.cap = "Summed latent Adélie nest abundances by season for all Adélie breeding sites in CCAMLR sub area 88.2 from 1980-2020. Abundance posterior distributions are represented with boxplots showing the median, 25-75%, and 10-90% (whiskers) credible intervals."}

ggplot(data = za_88_2_df, aes(x = season, group = season)) +
  geom_boxplot(aes(ymin = X10., lower = X25., middle = X50., upper = X75., ymax = X90.), stat = "identity",
  width = 0.5, outlier.shape = NA, alpha = 0.8, fill = "#EBB261") +
  labs(y = "nest abudance\n", x = NULL, title = "88.2") +
  guides(fill = FALSE, color = FALSE) +
  theme_minimal() +
  theme(text = element_text(size = 15))   
```  

```{r, echo = FALSE, fig.align = TRUE, fig.width = 12, echo = FALSE, message = FALSE, fig.cap = "Summed latent Adélie nest abundances by season for all Adélie breeding sites in CCAMLR sub area 88.3 from 1980-2020. Abundance posterior distributions are represented with boxplots showing the median, 25-75%, and 10-90% (whiskers) credible intervals."}

ggplot(data = za_88_3_df, aes(x = season, group = season)) +
  geom_boxplot(aes(ymin = X10., lower = X25., middle = X50., upper = X75., ymax = X90.), stat = "identity",
  width = 0.5, outlier.shape = NA, alpha = 0.8, fill = "#EBB261") +
  labs(y = "nest abudance\n", x = NULL, title = "88.3") +
  guides(fill = FALSE, color = FALSE) +
  theme_minimal() +
  theme(text = element_text(size = 15))   
```  

```{r, echo = FALSE, fig.align = TRUE, fig.width = 12, echo = FALSE, message = FALSE, fig.cap = "Summed latent Adélie nest abundances by season for all Adélie breeding sites in CCAMLR sub area 58.4.1 from 1980-2020. Abundance posterior distributions are represented with boxplots showing the median, 25-75%, and 10-90% (whiskers) credible intervals."}

ggplot(data = za_58_4_1_df, aes(x = season, group = season)) +
  geom_boxplot(aes(ymin = X10., lower = X25., middle = X50., upper = X75., ymax = X90.), stat = "identity",
  width = 0.5, outlier.shape = NA, alpha = 0.8, fill = "#EBB261") +
  labs(y = "nest abudance\n", x = NULL, title = "58.4.1") +
  guides(fill = FALSE, color = FALSE) +
  theme_minimal() +
  theme(text = element_text(size = 15))   
```  

```{r, echo = FALSE, fig.align = TRUE, fig.width = 12, echo = FALSE, message = FALSE, fig.cap = "Summed latent Adélie nest abundances by season for all Adélie breeding sites in CCAMLR sub area 58.4.2 from 1980-2020. Abundance posterior distributions are represented with boxplots showing the median, 25-75%, and 10-90% (whiskers) credible intervals."}

ggplot(data = za_58_4_2_df, aes(x = season, group = season)) +
  geom_boxplot(aes(ymin = X10., lower = X25., middle = X50., upper = X75., ymax = X90.), stat = "identity",
  width = 0.5, outlier.shape = NA, alpha = 0.8, fill = "#EBB261") +
  labs(y = "nest abudance\n", x = NULL, title = "58.4.2") +
  guides(fill = FALSE, color = FALSE) +
  theme_minimal() +
  theme(text = element_text(size = 15))   
```  

## Region

```{r, echo = FALSE, fig.align = TRUE, fig.width = 12, echo = FALSE, message = FALSE, fig.cap = "Summed latent Adélie nest abundances by season for all Adélie breeding sites in Central-west and Northwest Antarctic Peninsula from 1980-2020. Abundance posterior distributions are represented with boxplots showing the median, 25-75%, and 10-90% (whiskers) credible intervals."}

ggplot(data = za_reg_list[[1]], aes(x = season, group = season)) +
  geom_boxplot(aes(ymin = X10., lower = X25., middle = X50., upper = X75., ymax = X90.), stat = "identity",
  width = 0.5, outlier.shape = NA, alpha = 0.8, fill = "#EBB261") +
  labs(y = "nest abudance\n", x = NULL, title = "Central-west and Northwest Antarctic Peninsula") +
  guides(fill = FALSE, color = FALSE) +
  theme_minimal() +
  theme(text = element_text(size = 15))   
```  

```{r, echo = FALSE, fig.align = TRUE, fig.width = 12, echo = FALSE, message = FALSE, fig.cap = "Summed latent Adélie nest abundances by season for all Adélie breeding sites in Southwest Antarctic Peninsula and Palmer Land from 1980-2020. Abundance posterior distributions are represented with boxplots showing the median, 25-75%, and 10-90% (whiskers) credible intervals."}

ggplot(data = za_reg_list[[2]], aes(x = season, group = season)) +
  geom_boxplot(aes(ymin = X10., lower = X25., middle = X50., upper = X75., ymax = X90.), stat = "identity",
  width = 0.5, outlier.shape = NA, alpha = 0.8, fill = "#EBB261") +
  labs(y = "nest abudance\n", x = NULL, title = "Southwest Antarctic Peninsula and Palmer Land") +
  guides(fill = FALSE, color = FALSE) +
  theme_minimal() +
  theme(text = element_text(size = 15))   
```  

```{r, echo = FALSE, fig.align = TRUE, fig.width = 12, echo = FALSE, message = FALSE, fig.cap = "Summed latent Adélie nest abundances by season for all Adélie breeding sites in Elephant Island, South Orkney Islands, and South Shetland Islands from 1980-2020. Abundance posterior distributions are represented with boxplots showing the median, 25-75%, and 10-90% (whiskers) credible intervals."}

ggplot(data = za_reg_list[[3]], aes(x = season, group = season)) +
  geom_boxplot(aes(ymin = X10., lower = X25., middle = X50., upper = X75., ymax = X90.), stat = "identity",
  width = 0.5, outlier.shape = NA, alpha = 0.8, fill = "#EBB261") +
  labs(y = "nest abudance\n", x = NULL, title = "Elephant Island, South Orkney Islands, and South Shetland Islands") +
  guides(fill = FALSE, color = FALSE) +
  theme_minimal() +
  theme(text = element_text(size = 15))   
```  

```{r, echo = FALSE, fig.align = TRUE, fig.width = 12, echo = FALSE, message = FALSE, fig.cap = "Summed latent Adélie nest abundances by season for all Adélie breeding sites in Northeast Antarctic Peninsula from 1980-2020. Abundance posterior distributions are represented with boxplots showing the median, 25-75%, and 10-90% (whiskers) credible intervals."}

ggplot(data = za_reg_list[[4]], aes(x = season, group = season)) +
  geom_boxplot(aes(ymin = X10., lower = X25., middle = X50., upper = X75., ymax = X90.), stat = "identity",
  width = 0.5, outlier.shape = NA, alpha = 0.8, fill = "#EBB261") +
  labs(y = "nest abudance\n", x = NULL, title = "Northeast Antarctic Peninsula") +
  guides(fill = FALSE, color = FALSE) +
  theme_minimal() +
  theme(text = element_text(size = 15))   
```  

```{r, echo = FALSE, fig.align = TRUE, fig.width = 12, echo = FALSE, message = FALSE, fig.cap = "Summed latent Adélie nest abundances by season for all Adélie breeding sites in CCAMLR sub area 88.1 and 88.2 from 1980-2020. Abundance posterior distributions are represented with boxplots showing the median, 25-75%, and 10-90% (whiskers) credible intervals."}

ggplot(data = za_reg_list[[5]], aes(x = season, group = season)) +
  geom_boxplot(aes(ymin = X10., lower = X25., middle = X50., upper = X75., ymax = X90.), stat = "identity",
  width = 0.5, outlier.shape = NA, alpha = 0.8, fill = "#EBB261") +
  labs(y = "nest abudance\n", x = NULL, title = "CCAMLR sub area 88.1 and 88.2") +
  guides(fill = FALSE, color = FALSE) +
  theme_minimal() +
  theme(text = element_text(size = 15))   
```  


## Site-level

```{r, fig.align = TRUE, fig.width = 10, fig.height = 10, echo = FALSE, message = FALSE, fig.cap = "Map displaying posterior distributions means for site-level average latent nest abundance population growth rate multipliers. For each site, this was computed as the geometric mean of the ratios of latent nest abundance in year t + 1 to year t for all seasons breeding occurred between 1970 and 2020."}

tile_url <- "https://overlord.pgc.umn.edu/arcgis/rest/services/imagery/ant_pgc_composite_mosaic/MapServer"

# define 3031 leaflet CRS
# resolution, origin, and bounds taken from LIMA metadata found at PGC WMS MapServer url (tile_url)
crs_3031 <- leaflet::leafletCRS(
  crsClass = 'L.Proj.CRS',
  code = 'EPSG:3031',
  proj4def = '+proj=stere +lat_0=-90 +lat_ts=-71 +lon_0=0 +k=1 +x_0=0 +y_0=0 +ellps=WGS84 +datum=WGS84 +units=m +no_defs',
  resolutions = c(32000.000000000004, 16000.000000000002, 8000.000000000001, 4000.0000000000005, 2000.0000000000002,
    1000.0000000000001, 500.00000000000006, 250.00000000000003, 120.00000000000001, 60.00000000000001, 30.000000000000004,
    15.000000000000002, 8, 4, 2, 1, .5),
  origin = c(-30636100, 30636099.999999993),
  bounds =  list( c(-3000000, 4000005.0001000017), c(3000000.0001, -3000000)))

# set color palettes for asd and mpa layers
factpal_asd <- leaflet::colorFactor(grDevices::topo.colors(base::nrow(asd_mask)), as.factor(asd_mask$ccamlr_id))
factpal_mpa <- leaflet::colorFactor(grDevices::hcl.colors(base::nrow(mpa_mask)), as.factor(mpa_mask$mpa_id))
pal <- colorNumeric(palette = "magma", domain = range(SiteList_lambda$mean, na.rm = TRUE))

leaflet::leaflet(
  options = leaflet::leafletOptions(
    crs = crs_3031,
    # min and max Zoom control the lowest (most zoomed out) and highest zoom level permitted
    # these values were set using the number of resolutions available for LIMA
    minZoom = 1,
    maxZoom = 16,
    # zoomSnap controls how small you can define the zoom level
    zoomSnap = 0.25,
    # zoomDelta controls how much the view zooms when clicking zoom control buttons
    zoomDelta = 0.5,
    # not sure if this matters but set to false it seemed to have weird behavior with sites
    # on islands outside of LIMA
    worldCopyJump = TRUE)) %>%
  # sets the long, lat, and starting zoom
  # zoom set to just show antarctica S of 60 S latitude on a 15 inch laptop screen
  leaflet::setView(0, -90, 2.25) %>%
  leaflet::addScaleBar(position = c("bottomleft")) %>%
  # add the land mask first
  leaflet::addPolygons(data = land_mask,
    color = "black",
    weight = 1,
    opacity = 1.0,
    fillOpacity = 0.5,
    fillColor = "lightgray",
    group = "CCAMLR Coastline") %>%
  # add ccamlr subareas
  leaflet::addPolygons(data = asd_mask,
    color = "black",
    weight = 1,
    opacity = 1.0,
    fillOpacity = 0.15,
    popup = asd_mask$ccamlr_id,
    fillColor = ~factpal_asd(ccamlr_id),
    group = "CCAMLR Statistical Areas and Divisions") %>%
  # add mpas
  leaflet::addPolygons(data = mpa_mask,
    color = "black",
    weight = 1,
    opacity = 1.0,
    fillOpacity = 0.15,
    popup = mpa_mask$mpa_id,
    fillColor = ~factpal_mpa(mpa_id),
    group = "CCAMLR Marine Protected Areas (MPA)") %>%
  # add Landsat Image Mosaic Of Antarctica (LIMA) WMS tile
  leaflet.esri::addEsriTiledMapLayer(tile_url, group = "Landsat Image Mosaic Of Antarctica (LIMA)") %>%
  # add penguin colonies
  leaflet::addCircleMarkers(
    data = SiteList_lambda,
    popup = SiteList_lambda$label_id,
    color = ~pal(SiteList_lambda$mean),
    group = "MAPPPD Penguin Colonies",
    clusterId = "ColonyClusters") %>%
  # specify groups and hide the CCAMLR ADD and MPA groups
  leaflet::addLayersControl(
    overlayGroups = c("CCAMLR Coastline", "CCAMLR Statistical Areas and Divisions", "CCAMLR Marine Protected Areas (MPA)",
      "Landsat Image Mosaic Of Antarctica (LIMA)", "MAPPPD Penguin Colonies"),
    options = leaflet::layersControlOptions(collapsed = FALSE)) %>%
  leaflet::hideGroup(c("CCAMLR Statistical Areas and Divisions", "CCAMLR Marine Protected Areas (MPA)", 
    "Landsat Image Mosaic Of Antarctica (LIMA)")) %>%
 # add zoom out button
  leaflet::addEasyButton(
    leaflet::easyButton(
      icon = "fa-globe",
      title = "Zoom Out",
      onClick = htmlwidgets::JS("function(btn, map){ map.setView([-90, 0], 2.25); }")
    )
  ) 
```

```{r, echo = FALSE}

plot_site <- function(focal_site) {
  
  focal_site_df <- SiteList_lambda %>% dplyr::filter(site == focal_site)
  lza_focal_site_df <- lza_df %>% dplyr::filter(site == focal_site)
  nests <- rbind(abundance_nests, abundance_initial) %>% 
    dplyr::filter(site == focal_site & season >= start_season & season <= end_season)
  chicks <- abundance_chicks %>% 
    dplyr::filter(site == focal_site & season >= start_season & season <= end_season)
  plot_title <- paste(focal_site_df$site_id, focal_site_df$site_name, focal_site_df$ccamlr, sep = ", ")
  plot_subtitle <- paste0("mean population growth multliplier = ", round(focal_site_df$mean, 3), " (", 
    round(focal_site_df$gl_min, 2), " - ", round(focal_site_df$gl_max, 2), ")")

  if (nrow(chicks) > 0) {
    p <- ggplot(data = lza_focal_site_df, aes(x = season, group = season)) +
      geom_point(data = chicks, aes(x = season + .5, y = q_med)) +
      geom_errorbar(data = chicks, aes(ymin = q_min, ymax = q_max, x = season + .5, y = q_med), width = .2) +
      geom_boxplot(aes(ymin = X10., lower = X25., middle = X50., upper = X75., ymax = X90.), stat = "identity",
        width = 0.5, outlier.shape = NA, alpha = 0.8, fill = "#EBB261") +
      geom_point(data = nests, aes(x = season, y = log(count)), size = 5, alpha = 0.5, color = "blue") +
      geom_point(data = chicks, aes(x = season + .5, y = log(count)), size = 5, alpha = 0.5, color = "#9D5A6C") +
      labs(y = "logged abudance\n", x = NULL, title = plot_title, subtitle = plot_subtitle) +
      guides(fill = FALSE, color = FALSE) +
      theme_minimal() +
      theme(text = element_text(size = 15))
  } else {
    p <- ggplot(data = lza_focal_site_df, aes(x = season, group = season)) +
      geom_boxplot(aes(ymin = X10., lower = X25., middle = X50., upper = X75., ymax = X90.), stat = "identity",
        width = 0.5, outlier.shape = NA, alpha = 0.8, fill = "#EBB261") +
      geom_point(data = nests, aes(x = season, y = log(count)), size = 5, alpha = 0.5, color = "blue") +
      labs(y = "logged abudance\n", x = NULL, title = plot_title, subtitle = plot_subtitle) +
      guides(fill = FALSE, color = FALSE) +
      theme_minimal() +
      theme(text = element_text(size = 15))      
  }
  return(p)
}
```

```{r, echo = FALSE}

plot_site_IQR <- function(focal_site) {
  
  focal_site_df <- SiteList_lambda %>% dplyr::filter(site == focal_site)
  lza_focal_site_df <- lza_df %>% dplyr::filter(site == focal_site)
  IQR_focal_site_df <- data.frame("IQR" = lza_focal_site_df[,4]-lza_focal_site_df[,2], "season" =
                                    lza_focal_site_df[,9])
  nests <- rbind(abundance_nests, abundance_initial) %>% 
    dplyr::filter(site == focal_site & season >= start_season & season <= end_season)
  chicks <- abundance_chicks %>% 
    dplyr::filter(site == focal_site & season >= start_season & season <= end_season)
  plot_title <- paste(focal_site_df$site_id, focal_site_df$site_name, focal_site_df$ccamlr, sep = ", ")
  
  p <- ggplot(IQR_focal_site_df, aes(x = season, y = IQR)) +
    geom_point(color = "#9D5A6C") +
    labs(y = "interquartile range, logged abundance\n", x = NULL, title = plot_title)
      
  return(p)
}
```

<br>

```{r, fig.align = TRUE, fig.width = 12, echo = FALSE, message = FALSE, results = "asis", fig.cap = "Logged latent and observed nest and chick abundance by site and season from 1980-2020. Nest abundances posterior distributions are represented with boxplots showing the median, 25-75%, and 10-90% (whiskers) credible intervals. Chick abundance posterior distributions are represented with lines for median and error bars for 90% equal-tailed credible intervals. The blue (red) dots represent observed logged nest (chick) counts. For each site we report the average latent nest abundance population growth rate multipliers. This was computed as the geometric mean of the ratios of latent nest abundance in year t + 1 to year t for all seasons breeding occurred 1970 and 2020. Note that observed and latent chick abundances are not available for all sites."}

for(i in 1:nrow(SiteList_lambda)) {
  print(plot_site(focal_site = i))
}

```

```{r, fig.align = TRUE, fig.width = 12, echo = FALSE, message = FALSE, results = "asis", fig.cap = "IQR vs. season"}

for(i in 1:nrow(SiteList_lambda)) {
  print(plot_site_IQR(focal_site = i))
}
```

# Distributions for Abundance

## Site/Years with new data
```{r, echo = FALSE, fig.align = TRUE, fig.cap = "BRDM, 2018"}
MCMCtrace(model_data_rinits_output, params = c("lz[36,49]"), ISB = FALSE, exact = TRUE, ind = TRUE, pdf = FALSE, ylim = c(0, 0.75), xlim = c(6, 14))
```

```{r, echo = FALSE, fig.align = TRUE, fig.cap = "BRDS, 2018"}
MCMCtrace(model_data_rinits_output, params = c("lz[38,49]"), ISB = FALSE, exact = TRUE, ind = TRUE, pdf = FALSE, ylim = c(0, 0.75), xlim = c(6, 14))
```

```{r, echo = FALSE, fig.align = TRUE, fig.cap = "ROYD, 2018"}
MCMCtrace(model_data_rinits_output, params = c("lz[210,49]"), ISB = FALSE, exact = TRUE, ind = TRUE, pdf = FALSE, ylim = c(0, 0.75), xlim = c(4, 12))
```

```{r, echo = FALSE, fig.align = TRUE, fig.cap = "ARDL, 2019"}
MCMCtrace(model_data_rinits_output, params = c("lz[13,50]"), ISB = FALSE, exact = TRUE, ind = TRUE, pdf = FALSE, ylim = c(0, 0.95), xlim = c(0, 8))
```

```{r, echo = FALSE, fig.align = TRUE, fig.cap = "CHAL, 2019"}
MCMCtrace(model_data_rinits_output, params = c("lz[46,50]"), ISB = FALSE, exact = TRUE, ind = TRUE, pdf = FALSE, ylim = c(0, 0.75), xlim = c(6, 14))
```

```{r, echo = FALSE, fig.align = TRUE, fig.cap = "INEX, 2019"}
MCMCtrace(model_data_rinits_output, params = c("lz[126,50]"), ISB = FALSE, exact = TRUE, ind = TRUE, pdf = FALSE, ylim = c(0, 0.75), xlim = c(6, 14))
```

```{r, echo = FALSE, fig.align = TRUE, fig.cap = "PETE, 2020"}
MCMCtrace(model_data_rinits_output, params = c("lz[189,51]"), ISB = FALSE, exact = TRUE, ind = TRUE, pdf = FALSE, ylim = c(0, 0.95), xlim = c(0, 8))
```

```{r, echo = FALSE, fig.align = TRUE, fig.cap = "YALO, 2020"}
MCMCtrace(model_data_rinits_output, params = c("lz[270,51]"), ISB = FALSE, exact = TRUE, ind = TRUE, pdf = FALSE, ylim = c(0, 0.75), xlim = c(4, 12))
```

## Site/Years with high PPL

```{r, echo = FALSE, fig.align = TRUE, fig.cap = "ADAM, 2009"}
MCMCtrace(model_data_rinits_output, params = c("lz[2,40]"), ISB = FALSE, exact = TRUE, ind = TRUE, pdf = FALSE, ylim = c(0, 1), xlim = c(0, 8))
```

```{r, echo = FALSE, fig.align = TRUE, fig.cap = "RBSN, 2005"}
MCMCtrace(model_data_rinits_output, params = c("lz[204,36]"), ISB = FALSE, exact = TRUE, ind = TRUE, pdf = FALSE, ylim = c(0, 1), xlim = c(4, 12))
```

```{r, echo = FALSE, fig.align = TRUE, fig.cap = "RBSN, 2006"}
MCMCtrace(model_data_rinits_output, params = c("lz[204,37]"), ISB = FALSE, exact = TRUE, ind = TRUE, pdf = FALSE, ylim = c(0, 1), xlim = c(4, 12))
```

```{r, echo = FALSE, fig.align = TRUE, fig.cap = "WPEC, 2010"}
MCMCtrace(model_data_rinits_output, params = c("lz[268,41]"), ISB = FALSE, exact = TRUE, ind = TRUE, pdf = FALSE, ylim = c(0, 1), xlim = c(4, 12))
```

<!--chapter:end:06-model_viz.Rmd-->

# MAPPPD outputs

```{r, echo = TRUE}

l_a_mean_sd <- cbind(
  data.frame(MCMCsummary(model_data_rinits_output, params = "l_a", n.eff = FALSE)[, c(1, 2, 4)]),
  w_df %>% arrange(season_relative, site) %>% dplyr::filter(season < max_season)) %>%
  dplyr::select(site_id, season, l_a_median = X50., l_a_mean = mean, l_a_sd = sd)
  
lza_mean_sd <- cbind(w_df %>% arrange(season_relative, site),
  data.frame(MCMCsummary(model_data_rinits_output, params = "lza", n.eff = FALSE)[, c(1, 2)])) %>%
  dplyr::select(site_id, season, w_1 = w, obs_1 = known_w, lza_mean = mean, lza_sd = sd)

presence_2 <- w_df %>%
  mutate(season = season - 1) %>%
  dplyr::select(site_id, season, w_2 = w, obs_2 = known_w)

ADPE_abundance_lambda <- lza_mean_sd %>%
  left_join(presence_2, by = c("site_id", "season")) %>%
  left_join(l_a_mean_sd, by = c("site_id", "season")) %>%
  left_join(SiteList, by = "site_id") %>%
  arrange(site_id, season) %>%
  mutate(lza_mean = replace(lza_mean, w_1 == 0, NA)) %>%
  mutate(lza_sd = replace(lza_sd, w_1 == 0, NA)) %>%
  mutate(l_a_mean = replace(l_a_mean, !(w_1 == 1 & w_2 == 1), NA)) %>%
  mutate(l_a_median = replace(l_a_median, !(w_1 == 1 & w_2 == 1), NA)) %>%
  mutate(l_a_sd = replace(l_a_sd, !(w_1 == 1 & w_2 == 1), NA)) %>%
  mutate(id = id, species_id = species) %>%
  dplyr::select(id, species_id, site_id, season, site_name, ccamlr_id, latitude, longitude, 
    w_1, w_2, obs_1, obs_2, lza_mean, lza_sd, l_a_median, l_a_mean, l_a_sd)
  
write_csv(ADPE_abundance_lambda, file = "_static/ADPE_abundance_lambda.csv")
save(ADPE_abundance_lambda, file = "_static/ADPE_abundance_lambda.rda")
```
 

<!--chapter:end:07-model_outputs.Rmd-->

